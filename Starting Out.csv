Title,Start_Page,Content
Location of Videonotes in the Text,14,"LOCATION OF VIDEONOTES IN THE TEXT Chapter 1 Introduction to Flowcharting, p. 20 Designing a Program with Pseudocode, p. 20 Designing the Account Balance Program, p. 25 Predicting the Result of Problem 33, p. 26 Chapter 2 Using cout, p. 31 Variabe Defi nitions, p. 37 Assignment Statements and Simple Math Expressions, p. 62 Solving the Restaurant Bill Problem, p. 80 Chapter 3 Reading Input with cin, p. 83 Formatting Numbers with setprecision, p. 111 Solving the Stadium Seating Problem, p. 142 Chapter 4 The if Statement, p. 154 The if/else statement, p. 166 The if/else if Statement, p. 176 Solving the Time Calculator Problem, p. 221 Chapter 5 The while Loop, p. 232 The for Loop, p. 247 Reading Data from a File, p. 274 Solving the Calories Burned Problem, p. 293 Chapter 6 Functions and Arguments, p. 311 Value-Returnlng Functions, p. 324 Solving the Markup Problem, p. 366 Chapter 7 Accessing Array Elements With a Loop, p. 380 Passing an Array to a Function, p. 407 Solving the Chips and ..."
1.1 Why Program?,32,"Why Program? CONCEPT: Computers can do many different jobs because they are programmable. Think about some of the different ways that people use computers. In school, students use computers for tasks such as writing papers, searching for articles, sending e-mail, and partici- pating in online classes. At work, people use computers to analyze data, make presentations, conduct business transactions, communicate with customers and coworkers, control machines in manufacturing facilities, and do many other things. At home, people use computers for tasks such as paying bills, shopping online, social networking, and playing computer games. And don’t forget that smart phones, iPods ® , car navigation systems, and many other devices are computers as well. The uses of computers are almost limitless in our everyday lives. Computers can do such a wide variety of things because they can be programmed. This means that computers are not designed to do just one job, but any job that their programs ..."
1.2 Computer Systems: Hardware and Software,33,"Computer Systems: Hardware and Software CONCEPT: All computer systems consist of similar hardware devices and software components. This section provides an overview of standard computer hardware and software organization. Figure 1-1 A word processing program and a presentation program 1.2 Computer Systems: Hardware and Software 3 Hardware Hardware refers to the physical components that a computer is made of. A computer, as we generally think of it, is not an individual device, but a system of devices. Like the instru- ments in a symphony orchestra, each device plays its own part. A typical computer system consists of the following major components: • The central processing unit (CPU) • Main memory • Secondary storage devices • Input devices • Output devices The organization of a computer system is depicted in Figure 1-2 . Input Devices Output Devices Secondary Storage Devices Central Processing Unit Main Memory (RAM) Figure 1-2 The CPU When a computer is performing the tasks that a ..."
1.3 Programs and Programming Languages,39,"Programs and Programming Languages CONCEPT: A program is a set of instructions a computer follows in order to perform a task. A programming language is a special language used to write computer programs. What Is a Program? Computers are designed to follow instructions. A computer program is a set of instructions that tells the computer how to solve a problem or perform a task. For example, suppose we want the computer to calculate someone’s gross pay. Here is a list of things the computer should do: 1. Display a message on the screen asking “How many hours did you work?” 2. Wait for the user to enter the number of hours worked. Once the user enters a number, store it in memory. 3. Display a message on the screen asking “How much do you get paid per hour?” 4. Wait for the user to enter an hourly pay rate. Once the user enters a number, store it in memory. 5. Multiply the number of hours by the amount paid per hour, and store the result in memory. 6. Display a message on the screen th..."
1.4 What Is a Program Made of?,45,"What Is a Program Made of? CONCEPT: There are certain elements that are common to all programming languages. Language Elements All programming languages have a few things in common. Table 1-2 lists the common ele- ments you will find in almost every language. Table 1-2 Language Element Description Key Words Words that have a special meaning. Key words may only be used for their intended purpose. Key words are also known as reserved words. Programmer-Defined Identifiers Words or names defined by the programmer. They are symbolic names that refer to variables or programming routines. Operators Operators perform operations on one or more operands. An operand is usually a piece of data, like a number. Punctuation Punctuation characters that mark the beginning or ending of a statement, or separate items in a list. Syntax Rules that must be followed when constructing a program. Syntax dictates how key words and operators may be used, and where punctuation symbols must appear. Let’s look a..."
"1.5 Input, Processing, and Output",48,"1.5 Input, Processing, and Output 17 In Figure 1-10 , the variable length is holding the value 72. The number 72 is actually stored in RAM at address 23, but the name length symbolically represents this storage location. If it helps, you can think of a variable as a box that holds information. In Figure 1-10 , the number 72 is stored in the box named length . Only one item may be stored in the box at any given time. If the program stores another value in the box, it will take the place of the number 72. Variable Definitions In programming, there are two general types of data: numbers and characters. Numbers are used to perform mathematical operations, and characters are used to print data on the screen or on paper. Numeric data can be categorized even further. For instance, the following are all whole numbers, or integers: 5 7 −129 32154 The following are real, or floating-point numbers: 3.14159 6.7 1.0002 When creating a variable in a C++ program, you must know what type of data th..."
1.6 The Programming Process,49,"The Programming Process CONCEPT: The programming process consists of several steps, which include design, creation, testing, and debugging activities. Designing and Creating a Program Now that you have been introduced to what a program is, it’s time to consider the process of creating a program. Quite often, when inexperienced students are given programming assignments, they have trouble getting started because they don’t know what to do first. If you find yourself in this dilemma, the steps listed in Figure 1-11 may help. These are the steps recommended for the process of writing a program. 1.6 The Programming Process 19 The steps listed in Figure 1-11 emphasize the importance of planning. Just as there are good ways and bad ways to paint a house, there are good ways and bad ways to create a program. A good program always begins with planning. With the pay-calculating program as our example, let’s look at each of the steps in more detail. 1. Clearly define what the program is to do..."
1.7 Procedural and Object-Oriented Programming,53,"Procedural and Object-Oriented Programming CONCEPT: Procedural programming and object-oriented programming are two ways of thinking about software development and program design. C++ is a language that can be used for two methods of writing computer programs: proce- dural programming and object-oriented programming . This book is designed to teach you some of both. In procedural programming, the programmer constructs procedures (or functions, as they are called in C++). The procedures are collections of programming statements that perform a specific task. The procedures each contain their own variables and commonly share vari- ables with other procedures. This is illustrated by Figure 1-13 . 1.7 Procedural and Object-Oriented Programming 23 Procedural programming is centered on the procedure, or function. Object-oriented pro- gramming (OOP), on the other hand, is centered on the object. An object is a programming element that contains data and the procedures that operate on the data..."
Review Questions and Exercises,55,"Review Questions and Exercises Short Answer 1. Both main memory and secondary storage are types of memory. Describe the differ- ence between the two. 2. What is the difference between system software and application software? 3. What type of software controls the internal operations of the computer’s hardware? 4. Why must programs written in a high-level language be translated into machine lan- guage before they can be run? 5. Why is it easier to write a program in a high-level language than in machine language? 6. Explain the difference between an object file and an executable file. 7. What is the difference between a syntax error and a logical error? Fill-in-the-Blank 8. Computers can do many different jobs because they can be __________. 9. The job of the __________ is to fetch instructions, carry out the operations com- manded by the instructions, and produce some outcome or resultant information. 10. Internally, the CPU consists of the __________ and the __________. 11. A(n) __..."
2.1 The Parts of a C++ Program,58,"The Parts of a C++ Program CONCEPT: C++ programs have parts and components that serve specific purposes. Every C++ program has an anatomy. Unlike human anatomy, the parts of C++ programs are not always in the same place. Nevertheless, the parts are there, and your first step in learning C++ is to learn what they are. We will begin by looking at Program 2-1 . Let’s examine the program line by line. Here’s the first line: // A simple C++ program The // marks the beginning of a comment . The compiler ignores everything from the double slash to the end of the line. That means you can type anything you want on that line and the compiler will never complain! Although comments are not required, they are very important to programmers. Most programs are much more complicated than the example in Program 2-1 , and comments help explain what’s going on. Introduction to C++ 2 TOPICS 2.1 The Parts of a C++ Program 2.2 The cout Object 2.3 The #include Directive 2.4 Variables and Literals 2.5 Ident..."
2.2 The cout Object,62,"2.2 The cout Object 31 2.2 The cout Object CONCEPT: Use the cout object to display information on the computer’s screen. In this section you will learn to write programs that produce output on the screen. The simplest type of screen output that a program can display is console output , which is merely plain text. The word console is an old computer term. It comes from the days when a computer operator interacted with the system by typing on a terminal. The terminal, which consisted of a simple screen and keyboard, was known as the console . On modern computers, running graphical operating systems such as Windows or Mac OS X, console output is usually displayed in a window such as the one shown in Figure 2-1 . In C++ you use the cout object to produce console output. (You can think of the word cout as meaning c onsole out put.) Figure 2-1 A Console Window cout is classified as a stream object , which means it works with streams of data. To print a message on the screen, you send a st..."
2.3 The #include Directive,67,"The #include Directive CONCEPT: The #include directive causes the contents of another file to be inserted into the program. Now is a good time to expand our discussion of the #include directive. The following line has appeared near the top of every example program. #include <iostream> The header file iostream must be included in any program that uses the cout object. This is because cout is not part of the “core” of the C++ language. Specifically, it is part of the input–output stream library . The header file, iostream , contains information describing iostream objects. Without it, the compiler will not know how to properly compile a pro- gram that uses cout . Preprocessor directives are not C++ statements. They are commands to the preprocessor, which runs prior to the compiler (hence the name “preprocessor”). The preprocessor’s job is to set programs up in a way that makes life easier for the programmer. For example, any program that uses the cout object must contain the extensive..."
2.4 Variables and Literals,68,"2.4 Variables and Literals 37 using namespace std; // It's a mad, mad program #include <iostream> cout << ""Success\n""; { return 0; When the lines are properly arranged the program should display the following on the screen: Program Output Success Success Success Success Rearrange the lines in the correct order. Test the program by entering it on the computer, compiling it, and running it. 2.3 Study the following program and show what it will print on the screen. // The Works of Wolfgang #include <iostream> using namespace std; int main() { cout << ""The works of Wolfgang\ninclude the following""; cout << ""\nThe Turkish March"" << endl; cout << ""and Symphony No. 40 ""; cout << ""in G minor."" << endl; return 0; } 2.4 On paper, write a program that will display your name on the first line, your street address on the second line, your city, state, and ZIP code on the third line, and your telephone number on the fourth line. Place a comment with today’s date at the top of the program. Test yo..."
2.5 Identifiers,72,"2.5 Identifiers 41 int main() { int number; number = 712; cout << ""The value is "" << ""number"" << endl; return 0; } 2.5 Identifiers CONCEPT: Choose variable names that indicate what the variables are used for. An identifier is a programmer-defined name that represents some element of a program. Variable names are examples of identifiers. You may choose your own variable names in C++, as long as you do not use any of the C++ key words. The key words make up the “core” of the language and have specific purposes. Table 2-4 shows a complete list of the C++ key words. Note that they are all lowercase. Table 2-4 The C++ Key Words alignas const for private throw alignof constexpr friend protected true and const_cast goto public try and_eq continue if register typedef asm decltype inline reinterpret_cast typeid auto default int return typename bitand delete long short union bitor do mutable signed unsigned bool double namespace sizeof using break dynamic_cast new static virtual case else noe..."
2.6 Integer Data Types,73,"Integer Data Types CONCEPT: There are many different types of data. Variables are classified according to their data type, which determines the kind of information that may be stored in them. Integer variables can only hold whole numbers. 2.6 Integer Data Types 43 Computer programs collect pieces of data from the real world and manipulate them in various ways. There are many different types of data. In the realm of numeric information, for example, there are whole numbers and fractional numbers. There are negative numbers and positive numbers. And there are numbers so large, and others so small, that they don’t even have a name. Then there is textual information. Names and addresses, for instance, are stored as groups of characters. When you write a program you must determine what types of information it will be likely to encounter. If you are writing a program to calculate the number of miles to a distant star, you’ll need variables that can hold very large numbers. If you are desi..."
2.7 The char Data Type,79,"The char Data Type The char data type is used to store individual characters. A variable of the char data type can hold only one character at a time. Here is an example of how you might declare a char variable: char letter; This statement declares a char variable named letter , which can store one character. In C++, character literals are enclosed in single quotation marks. Here is an example showing how we would assign a character to the letter variable: letter = 'g'; This statement assigns the character 'g' to the letter variable. Because char variables can hold only one character, they are not compatible with strings. For example, you can- not assign a string to a char variable, even if the string contains only one character. The following statement, for example, will not compile because it attempts to assign a string literal to a char variable. letter = ""g""; // ERROR! Cannot assign a string to a char It is important that you do not confuse character literals, which are enclosed ..."
2.8 The C++ string Class,83,"The C++ string Class CONCEPT: Standard C++ provides a special data type for storing and working with strings. Because a char variable can store only one character in its memory location, another data type is needed for a variable able to hold an entire string. Although C++ does not have a built-in data type able to do this, standard C++ provides something called the string class that allows the programmer to create a string type variable. Using the string Class The first step in using the string class is to #include the string header file. This is accomplished with the following preprocessor directive: #include <string> The next step is to define a string type variable, called a string object. Defining a string object is similar to defining a variable of a primitive type. For example, the following state- ment defines a string object named movieTitle . string movieTitle; You can assign a string literal to movieTitle with the assignment operator: movieTitle = ""Wheels of Fury""; You ca..."
2.9 Floating-Point Data Types,85,"Floating-Point Data Types CONCEPT: Floating-point data types are used to define variables that can hold real numbers. Whole numbers are not adequate for many jobs. If you are writing a program that works with dollar amounts or precise measurements, you need a data type that allows fractional values. In programming terms, these are called floating-point numbers. Internally, floating-point numbers are stored in a manner similar to scientific notation. Take the number 47,281.97. In scientific notation this number is 4.728197 * 10 4 . (10 4 is equal to 10,000, and 4.728197 * 10,000 is 47,281.97.) The first part of the number, 4.728197, is called the mantissa. The mantissa is multiplied by a power of ten. Computers typically use E notation to represent floating-point values. In E notation, the number 47,281.97 would be 4.728197E4. The part of the number before the E is the man- tissa, and the part after the E is the power of 10. When a floating point number is stored in memory, it is sto..."
2.10 The bool Data Type,88,"2.10 The bool Data Type 57 When the float variable f is assigned to the int variable i , the value being assigned (7.5) is truncated. After this code executes i will hold the value 7 and f will hold the value 7.5. NOTE: When a floating-point value is truncated, it is not rounded. Assigning the value 7.9 to an int variable will result in the value 7 being stored in the variable. WARNING! Floating-point variables can hold a much larger range of values than integer variables can. If a floating-point value is being stored in an integer variable, and the whole part of the value (the part before the decimal point) is too large for the integer variable, an invalid value will be stored in the integer variable. 2.10 The bool Data Type CONCEPT: Boolean variables are set to either true or false . Expressions that have a true or false value are called Boolean expressions, named in honor of English mathematician George Boole (1815–1864). The bool data type allows you to create small integer vari..."
2.11 Determining the Size of a Data Type,89,"2.11 Determining the Size of a Data Type CONCEPT: The sizeof operator may be used to determine the size of a data type on any system. Chapter 1 discussed the portability of the C++ language. As you have seen in this chap- ter, one of the problems of portability is the lack of common sizes of data types on all machines. If you are not sure what the sizes of data types are on your computer, C++ provides a way to find out. A special operator called sizeof will report the number of bytes of memory used by any data type or variable. Program 2-18 illustrates its use. The first line that uses the operator is line 10: cout << ""The size of an integer is "" << sizeof(int); The name of the data type or variable is placed inside the parentheses that follow the operator. The operator “returns” the number of bytes used by that item. This operator can be invoked anywhere you can use an unsigned integer, including in mathematical operations. Program 2-18 1 // This program determines the size of inte..."
2.12 Variable Assignments and Initialization,90,"2.12 Variable Assignments and Initialization 59 Checkpoint 2.18 Yes or No: Is there an unsigned floating point data type? If so, what is it? 2.19 How would the following number in scientific notation be represented in E notation? 6.31  1017 2.20 Write a program that defines an integer variable named age and a float variable named weight . Store your age and weight, as literals, in the variables. The program should display these values on the screen in a manner similar to the following: Program Output My age is 26 and my weight is 180 pounds. (Feel free to lie to the computer about your age and your weight— it’ll never know!) 2.12 Variable Assignments and Initialization CONCEPT: An assignment operation assigns, or copies, a value into a variable. When a value is assigned to a variable as part of the variable’s definition, it is called an initialization. As you have already seen in several examples, a value is stored in a variable with an assignment statement . For example, the follo..."
2.13 Scope,92,"2.13 Scope CONCEPT: A variable’s scope is the part of the program that has access to the variable. Every variable has a scope . The scope of a variable is the part of the program where the variable may be used. The rules that define a variable’s scope are complex, and you will only be introduced to the concept here. In other sections of the book we will revisit this topic and expand on it. The first rule of scope you should learn is that a variable cannot be used in any part of the program before the definition. Program 2-20 illustrates this. Program 2-20 1 // This program can't find its variable. 2 #include <iostream> 3 using namespace std; 4 5 int main() 6 { 7 cout << value; // ERROR! value not defined yet! 8 9 int value = 100; 10 return 0; 11 } The program will not work because line 7 attempts to send the contents of the variable value to cout before the variable is defined. The compiler reads your program from top to bottom. If it encounters a statement that uses a variable befo..."
2.14 Arithmetic Operators,92,"2.14 Arithmetic Operators 61 These examples show how to use the auto key word, but they don’t really show its useful- ness. The auto key word is intended to simplify the syntax of declarations that are more complex than the ones shown here. Later in the book, you will see examples of how the auto key word can improve the readability of complex definition statements. 2.13 Scope CONCEPT: A variable’s scope is the part of the program that has access to the variable. Every variable has a scope . The scope of a variable is the part of the program where the variable may be used. The rules that define a variable’s scope are complex, and you will only be introduced to the concept here. In other sections of the book we will revisit this topic and expand on it. The first rule of scope you should learn is that a variable cannot be used in any part of the program before the definition. Program 2-20 illustrates this. Program 2-20 1 // This program can't find its variable. 2 #include <iostream> 3..."
2.15 Comments,100,"2.15 Comments 69 Checkpoint 2.21 Is the following assignment statement valid or invalid? If it is invalid, why? 72 = amount; 2.22 How would you consolidate the following definitions into one statement? int x = 7; int y = 16; int z = 28; 2.23 What is wrong with the following program? How would you correct it? #include <iostream> using namespace std; int main() { number = 62.7; double number; cout << number << endl; return 0; } 2.24 Is the following an example of integer division or floating-point division? What value will be stored in portion ? portion = 70 / 3; 2.15 Comments CONCEPT: Comments are notes of explanation that document lines or sections of a program. Comments are part of the program, but the compiler ignores them. They are intended for people who may be reading the source code. It may surprise you that one of the most important parts of a program has absolutely no impact on the way it runs. In fact, the compiler ignores this part of a program. Of course, I’m speaking of ..."
2.16 Named Constants,102,"2.16 Named Constants 71 9 using namespace std; 10 11 int main() 12 { 13 double payRate; // Holds the hourly pay rate 14 double hours; // Holds the hours worked 15 int employNumber; // Holds the employee number (The remainder of this program is left out.) Unlike a comment started with // , a multi-line comment can span several lines. This makes it more convenient to write large blocks of comments because you do not have to mark every line. Consequently, the multi-line comment is inconvenient for writing single-line comments because you must type both a beginning and ending comment symbol. NOTE: Many programmers use a combination of single-line comments and multi-line comments in their programs. Convenience usually dictates which style to use. Remember the following advice when using multi-line comments: • Be careful not to reverse the beginning symbol with the ending symbol. • Be sure not to forget the ending symbol. Both of these mistakes can be difficult to track down and will prev..."
2.17 Programming Style,104,"2.17 Programming Style 73 12 double circumference; 13 14 // Calculate the circumference. 15 circumference = PI * DIAMETER; 16 17 // Display the circumference. 18 cout << ""The circumference is: "" << circumference << endl; 19 return 0; 20 } Program Output The circumference is: 31.4159 Let’s take a closer look at the program. Line 8 defines a constant double named PI , initial- ized with the value 3.14159. This constant will be used for the value of pi in the program’s calculation. Line 9 defines a constant double named DIAMETER , initialized with the value 10. This will be used for the circle’s diameter. Line 12 defines a double variable named circumference , which will be used to hold the circle’s circumference. Line 15 calculates the circle’s circumference by multiplying PI by DIAMETER . The result of the calculation is assigned to the circumference variable. Line 18 displays the circle’s circumference. Checkpoint 2.25 Write statements using the const qualifier to create named const..."
Review Questions and Exercises,106,"Review Questions and Exercises 75 Another aspect of programming style is how to handle statements that are too long to fit on one line. Because C++ is a free-flowing language, it is usually possible to spread a statement over several lines. For example, here is a cout statement that uses five lines: cout << ""The Fahrenheit temperature is "" << fahrenheit << "" and the Celsius temperature is "" << celsius << endl; This statement will work just as if it were typed on one line. Here is an example of variable definitions treated similarly: int fahrenheit, celsius, kelvin; There are many other issues related to programming style. They will be presented through- out the book. Review Questions and Exercises Short Answer 1. How many operands does each of the following types of operators require? _______ Unary _______ Binary _______ Ternary 2. How may the double variables temp , weight , and age be defined in one statement? 3. How may the int variables months , days , and years be defined in on..."
3.1 The cin Object,114,"The cin Object 3.2 Mathematical Expressions 3.3 When You Mix Apples and Oranges: Type Conversion 3.4 Overflow and Underflow 3.5 Type Casting 3.6 Multiple Assignment and Combined Assignment 3.7 Formatting Output 3.8 Working with Characters and string Objects 3.9 More Mathematical Library Functions 3.10 Focus on Debugging: Hand Tracing a Program 3.11 Focus on Problem Solving: A Case Study C H A P T E R 3.1 The cin Object CONCEPT: The cin object can be used to read data typed at the keyboard. So far you have written programs with built-in data. Without giving the user an opportu- nity to enter his or her own data, you have initialized the variables with the necessary start- ing values. These types of programs are limited to performing their task with only a single set of starting data. If you decide to change the initial value of any variable, the program must be modified and recompiled. In reality, most programs ask for values that will be assigned to variables. This means the program..."
3.2 Mathematical Expressions,120,"3.2 Mathematical Expressions 89 3.2 Mathematical Expressions CONCEPT: C++ allows you to construct complex mathematical expressions using multiple operators and grouping symbols. In Chapter 2 you were introduced to the basic mathematical operators, which are used to build mathematical expressions. An expression is a programming statement that has a value. Usually, an expression consists of an operator and its operands. Look at the follow- ing statement: sum = 21 + 3; Since 21 + 3 has a value, it is an expression. Its value, 24, is stored in the variable sum . Expressions do not have to be in the form of mathematical operations. In the following statement, 3 is an expression. number = 3; Here are some programming statements where the variable result is being assigned the value of an expression: result = x; result = 4; result = 15 / 3; result = 22 * number; result = sizeof(int); result = a + b + c; In each of these statements, a number, variable name, or mathematical expression appears..."
3.3 When You Mix Apples and Oranges: Type Conversion,129,"When You Mix Apples and Oranges: Type Conversion CONCEPT: When an operator’s operands are of different data types, C++ will automatically convert them to the same data type. This can affect the results of mathematical expressions. If an int is multiplied by a float , what data type will the result be? What if a double is divided by an unsigned int ? Is there any way of predicting what will happen in these instances? The answer is yes. C++ follows a set of rules when performing mathematical operations on variables of different data types. It’s helpful to understand these rules to prevent subtle errors from creeping into your programs. Just like officers in the military, data types are ranked. One data type outranks another if it can hold a larger number. For example, a float outranks an int . Table 3-7 lists the data types in order of their rank, from highest to lowest. Table 3-7 Data Type Ranking long double double float unsigned long long unsigned int int One exception to the ranki..."
3.4 Overflow and Underflow,131,"Overflow and Underflow CONCEPT: When a variable is assigned a value that is too large or too small in range for that variable’s data type, the variable overflows or underflows. Trouble can arise when a variable is being assigned a value that is too large for its type. Here is a statement where a , b , and c are all short integers: a = b * c; If b and c are set to values large enough, the multiplication will produce a number too big to be stored in a . To prepare for this, a should have been defined as an int , or a long int . When a variable is assigned a number that is too large for its data type, it overflows. Likewise, assigning a value that is too small for a variable causes it to underflow. Program 3-7 shows what happens when an integer overflows or underflows. (The output shown is from a system with two-byte short integers.) Program 3-7 1 // This program demonstrates integer overflow and underflow. 2 #include <iostream> 3 using namespace std; 4 5 int main() 6 { 7 // testVar is..."
3.5 Type Casting,132,"3.5 Type Casting 101 contents to wrap back around to 32,767. No warning or error message is given, so be care- ful when working with numbers close to the maximum or minimum range of an integer. If an overflow or underflow occurs, the program will use the incorrect number and therefore produce incorrect results. When floating-point variables overflow or underflow, the results depend upon how the compiler is configured. Your system may produce programs that do any of the following: • Produces an incorrect result and continues running. • Prints an error message and immediately stops when either floating point overflow or underflow occurs. • Prints an error message and immediately stops when floating point overflow occurs, but stores a 0 in the variable when it underflows. • Gives you a choice of behaviors when overflow or underflow occurs. You can find out how your system reacts by compiling and running Program 3-8 . Program 3-8 1 // This program can be used to see how your system hand..."
3.6 Multiple Assignment and Combined Assignment,135,"Multiple Assignment and Combined Assignment CONCEPT: Multiple assignment means to assign the same value to several variables with one statement. C++ allows you to assign a value to multiple variables at once. If a program has several variables, such as a , b , c , and d , and each variable needs to be assigned a value, such as 12, the following statement may be constructed: a = b = c = d = 12; The value 12 will be assigned to each variable listed in the statement. * * The assignment operator works from right to left. 12 is first assigned to d , then to c , then to b , then to a . 3.6 Multiple Assignment and Combined Assignment 105 Combined Assignment Operators Quite often, programs have assignment statements of the following form: number = number + 1; The expression on the right side of the assignment operator gives the value of number plus 1. The result is then assigned to number , replacing the value that was previously stored there. Effectively, this statement adds 1 to number . ..."
3.7 Formatting Output,139,"Formatting Output CONCEPT: The cout object provides ways to format data as it is being displayed. This affects the way data appears on the screen. The same data can be printed or displayed in several different ways. For example, all of the following numbers have the same value, although they look different: 720 720.0 720.00000000 7.2e+2 +720.0 The way a value is printed is called its formatting. The cout object has a standard way of formatting variables of each data type. Sometimes, however, you need more control over the way data is displayed. Consider Program 3-12 , for example, which displays three rows of numbers with spaces between each one. Program 3-12 1 // This program displays three rows of numbers. 2 #include <iostream> 3 using namespace std; 4 5 int main() 6 { 7 int num1 = 2897, num2 = 5, num3 = 837, 3.7 Formatting Output 109 8 num4 = 34, num5 = 7, num6 = 1623, 9 num7 = 390, num8 = 3456, num9 = 12; 10 11 // Display the first row of numbers 12 cout << num1 << "" "" << num2 <..."
3.8 Working with Characters and string Objects,149,"Working with Characters and string Objects CONCEPT: Special functions exist for working with characters and string objects. Although it is possible to use cin with the >> operator to input strings, it can cause prob- lems that you need to be aware of. When cin reads input, it passes over and ignores any leading whitespace characters (spaces, tabs, or line breaks). Once it comes to the first non- blank character and starts reading, it stops reading when it gets to the next whitespace character. Program 3-18 illustrates this problem. Program 3-18 1 // This program illustrates a problem that can occur if 2 // cin is used to read character data into a string object. 3 #include <iostream> 4 #include <string> 5 using namespace std; 6 7 int main() 8 { 9 string name; 10 string city; 11 12 cout << ""Please enter your name: ""; 13 cin >> name; 14 cout << ""Enter the city you live in: ""; 15 cin >> city; 16 3.8 Working with Characters and string Objects 119 17 cout << ""Hello, "" << name << endl; 18..."
3.9 More Mathematical Library Functions,155,"More Mathematical Library Functions CONCEPT: The C++ runtime library provides several functions for performing com- plex mathematical operations. Earlier in this chapter you learned to use the pow function to raise a number to a power. The C++ library has numerous other functions that perform specialized mathematical opera- tions. These functions are useful in scientific and special-purpose programs. Table 3-13 shows several of these, each of which requires the cmath header file. 3.9 More Mathematical Library Functions 125 Each of these functions is as simple to use as the pow function. The following program seg- ment demonstrates the sqrt function, which returns the square root of a number: cout << ""Enter a number: ""; cin >> num; s = sqrt(num); cout << ""The square root of "" << num << "" is "" << s << endl; Here is the output of the program segment, with 25 as the number entered by the user: Enter a number: 25 The square root of 25 is 5 Program 3-24 shows the sqrt function being used ..."
3.10 Focus on Debugging: Hand Tracing a Program,161,"3.10 Focus on Debugging: Hand Tracing a Program Hand tracing is a debugging process where you pretend that you are the computer execut- ing a program. You step through each of the program’s statements one by one. As you look at a statement, you record the contents that each variable will have after the statement exe- cutes. This process is often helpful in finding mathematical mistakes and other logic errors. To hand trace a program you construct a chart with a column for each variable. The rows in the chart correspond to the lines in the program. For example, Program 3-27 is shown with a hand trace chart. The program uses the following four variables: num1 , num2 , num3 , and avg . Notice that the hand trace chart has a column for each variable and a row for each line of code in function main . Program 3-27 1 // This program asks for three numbers, then 2 // displays the average of the numbers. 3 #include <iostream> 4 using namespace std; 5 int main() 6 { num1 num2 num3 avg 7 doubl..."
3.11 Focus on Problem Solving: A Case Study,163,"3.11 Focus on Problem Solving: A Case Study General Crates, Inc. builds custom-designed wooden crates. With materials and labor, it costs GCI $0.23 per cubic foot to build a crate. In turn, they charge their customers $0.50 per cubic foot for the crate. You have been asked to write a program that calculates the volume (in cubic feet), cost, customer price, and profit of any crate GCI builds. Variables Table 3-14 shows the named constants and variables needed. Table 3-14 Constant or Variable Description COST_PER_CUBIC_FOOT A named constant, declared as a double and initialized with the value 0.23. This represents the cost to build a crate, per cubic foot. CHARGE_PER_CUBIC_FOOT A named constant, declared as a double and initialized with the value 0.5. This represents the amount charged for a crate, per cubic foot. length A double variable to hold the length of the crate, which is input by the user. width A double variable to hold the width of the crate, which is input by the user. hei..."
Review Questions and Exercises,167,Review Questions and Exercises Short Answer 1. Assume that the following variables are defined: int age; double pay; char section; Write a single cin statement that will read input into each of these variables. 2. Assume a string object has been defined as follows: string description; A) Write a cin statement that reads in a one-word string. B) Write a statement that reads in a string that can contain multiple words separated by blanks. 3. What header files must be included in the following program? int main() { double amount = 89.7; cout << showpoint << fixed; cout << setw(8) << amount << endl; return 0; } 4. Complete the following table by writing the value of each expression in the Value column. Expression Value 28 / 4 − 2 6 + 12 * 2 − 8 4 + 8 * 2 6 + 17 % 3 − 2 2 + 22 * (9 − 7) (8 + 7) * 2 (16 + 7) % 2 − 1 12 / (10 − 6) (19 − 3) * (2 + 2) / 4 5. Write C++ expressions for the following algebraic expressions: a  12x z  5x  14y  6k y  x4 g  h  12 4k c  a3 b2k4 136 Chapter 3...
4.1 Relational Operators,180,"Relational Operators CONCEPT: Relational operators allow you to compare numeric and char values and determine whether one is greater than, less than, equal to, or not equal to another. So far, the programs you have written follow this simple scheme: • Gather input from the user. • Perform one or more calculations. • Display the results on the screen. Computers are good at performing calculations, but they are also quite adept at comparing values to determine if one is greater than, less than, or equal to the other. These types of operations are valuable for tasks such as examining sales figures, determining profit and loss, checking a number to ensure it is within an acceptable range, and validating the input given by a user. Numeric data is compared in C++ by using relational operators. Each relational opera- tor determines whether a specific relationship exists between two values. For example, Making Decisions 4 TOPICS 4.1 Relational Operators 4.2 The if Statement 4.3 Expanding th..."
4.2 The if Statement,185,"Statement 4.2 Indicate whether the following statements about relational expressions are correct or incorrect. A) x <= y is the same as y > x. B) x != y is the same as y >= x . C) x >= y is the same as y <= x. 4.3 Answer the following questions with a yes or no. A) If it is true that x > y and it is also true that x < z, does that mean y < z is true? B) If it is true that x >= y and it is also true that z == x , does that mean that z == y is true? C) If it is true that x != y and it is also true that x != z, does that mean that z != y is true? 4.4 What will the following program display? #include <iostream> using namespace std; int main () { int a = 0, b = 2, x = 4, y = 0; cout << (a == b) << endl; cout << (a != y) << endl; cout << (b <= x) << endl; cout << (y > a) << endl; return 0; } 4.2 The if Statement CONCEPT: The if statement can cause other statements to execute only under certain conditions. You might think of the statements in a procedural program as individual steps taken ..."
4.3 Expanding the if Statement,193,"Expanding the if Statement CONCEPT: The if statement can conditionally execute a block of statements enclosed in braces. What if you want an if statement to conditionally execute a group of statements, not just one line? For instance, what if the test averaging program needed to use several cout 4.3 Expanding the if Statement 163 statements when a high score was reached? The answer is to enclose all of the condition- ally executed statements inside a set of braces. Here is the format: if ( expression) { statement; statement; // Place as many statements here as necessary. } Program 4-6 , another modification of the test-averaging program, demonstrates this type of if statement. Program 4-6 1 // This program averages 3 test scores. 2 // It demonstrates an if statement executing 3 // a block of statements. 4 #include <iostream> 5 #include <iomanip> 6 using namespace std; 7 8 int main() 9 { 10 const int HIGH_SCORE = 95; // A high score is 95 or greater 11 int score1, score2, score3; // ..."
4.4 The if/else Statement,197,"The if/else Statement CONCEPT: The if/else statement will execute one group of statements if the expression is true, or another group of statements if the expression is false. The if/else statement is an expansion of the if statement. Here is its format: if ( expression) statement or block else statement or block As with the if statement, an expression is evaluated. If the expression is true, a statement or block of statements is executed. If the expression is false, however, a separate group of statements is executed. Program 4-8 uses the if/else statement along with the modulus operator to determine if a number is odd or even. Program 4-8 1 // This program uses the modulus operator to determine 2 // if a number is odd or even. If the number is evenly divisible 3 // by 2, it is an even number. A remainder indicates it is odd. 4 #include <iostream> 5 using namespace std; 6 7 int main() 8 { 9 int number; 10 11 cout << ""Enter an integer and I will tell you if it\n""; 12 cout << ""is odd..."
4.5 Nested if Statements,200,"4.5 Nested if Statements 169 4.5 Nested if Statements CONCEPT: To test more than one condition, an if statement can be nested inside another if statement. Sometimes an if statement must be nested inside another if statement. For example, con- sider a banking program that determines whether a bank customer qualifies for a special, low interest rate on a loan. To qualify, two conditions must exist: (1) the customer must be currently employed, and (2) the customer must have recently graduated from college (in the past two years). Figure 4-7 shows a flowchart for an algorithm that could be used in such a program. Figure 4-7 If we follow the flow of execution in the flowchart, we see that the expression employed == 'Y' is tested. If this expression is false, there is no need to perform further tests; we know that the customer does not qualify for the special interest rate. If the expression is true, however, we need to test the second condition. This is done with a nested decision struct..."
4.6 The if/else if Statement,207,"The if/else if Statement CONCEPT: The if/else if statement tests a series of conditions. It is often simpler to test a series of conditions with the if/else if statement than with a set of nested if/else statements. Even though Program 4-12 is a simple example, the logic of the nested decision structure is fairly complex. In C++, and many other languages, you can alternatively test a series of con- ditions using the if/else if statement. The if/else if statement makes certain types of nested decision logic simpler to write. Here is the general format of the if/else if statement: if ( expression_1 ) { statement statement etc . } else if ( expression_2 ) { statement statement etc . } Insert as many else if clauses as necessary else { statement statement etc . } VideoNote The if/else if Statement If expression_1 is true these state- ments are executed, and the rest of the structure is ignored. Otherwise, if expression_2 is true these statements are executed, and the rest of the structu..."
4.7 Flags,212,"4.7 Flags 181 else numCoupons = 3; cout << ""The number of coupons to give is "" << numCoupons << endl; If the customer purchases this many books This many coupons are given. 1 3 4 5 10 4.7 Flags CONCEPT: A flag is a Boolean or integer variable that signals when a condition exists. A flag is typically a bool variable that signals when some condition exists in the program. When the flag variable is set to false , it indicates that the condition does not exist. When the flag variable is set to true , it means the condition does exist. For example, suppose a program that calculates sales commissions has a bool variable, defined and initialized as shown here: bool salesQuotaMet = false; In the program, the salesQuotaMet variable is used as a flag to indicate whether a sales- person has met the sales quota. When we define the variable, we initialize it with false because we do not yet know if the salesperson has met the sales quota. Assuming a variable named sales holds the amount of sales..."
4.8 Logical Operators,213,"Logical Operators CONCEPT: Logical operators connect two or more relational expressions into one or reverse the logic of an expression. In the previous section you saw how a program tests two conditions with two if statements. In this section you will see how to use logical operators to combine two or more relational expressions into one. Table 4-6 lists C++’s logical operators. Table 4-6 Operator Meaning Effect && AND Connects two expressions into one. Both expressions must be true for the overall expression to be true. || OR Connects two expressions into one. One or both expressions must be true for the overall expression to be true. It is only necessary for one to be true, and it does not matter which. ! NOT The ! operator reverses the ""truth"" of an expression. It makes a true expression false, and a false expression true. The && Operator The && operator is known as the logical AND operator. It takes two expressions as oper- ands and creates an expression that is true only when b..."
4.9 Checking Numeric Ranges with Logical Operators,220,"4.9 Checking Numeric Ranges with Logical Operators 189 The logical operators have left-to-right associativity. In the following expression, a < b is evaluated before y == z. a < b || y == z In the following expression, y == z is evaluated first, however, because the && operator has higher precedence than ||. a < b || y == z && m > j The expression is equivalent to (a < b) || ((y == z) && (m > j)) 4.9 Checking Numeric Ranges with Logical Operators CONCEPT: Logical operators are effective for determining whether a number is in or out of a range. When determining whether a number is inside a numeric range, it’s best to use the && opera- tor. For example, the following if statement checks the value in x to determine whether it is in the range of 20 through 40: if (x >= 20 && x <= 40) cout << x << "" is in the acceptable range.\n""; The expression in the if statement will be true only when x is both greater than or equal to 20 AND less than or equal to 40. x must be within the range of 20 ..."
4.10 Menus,221,"4.10 Menus CONCEPT: You can use nested if/else statements or the if/else if statement to create menu-driven programs. A menu-driven program allows the user to determine the course of action by selecting it from a list of actions. A menu is a screen displaying a set of choices the user selects from. For example, a program that manages a mailing list might give you the following menu: 1. Add a name to the list. 2. Remove a name from the list. 3. Change a name in the list. 4. Print the list. 5. Quit the program. The user selects one of the operations by entering its number. Entering 4, for example, causes the mailing list to be printed, and entering 5 causes the program to end. Nested if/else statements or an if/else if structure can be used to set up such a menu. After the user enters a number, the program compares the number with the available selections and executes the statements that perform that operation. Program 4-18 calculates the charges for membership in a health club. The c..."
4.11 Focus on Software Engineering: Validating User Input,224,"4.11 Focus on Software Engineering: Validating User Input 193 • Otherwise, if the user selected 2 from the menu (child membership), the statements in lines 47–50 are executed. • Otherwise, if the user selected 3 from the menu (senior citizen membership), the statements in lines 54–57 are executed. • Otherwise, if the user selected 4 from the menu (quit the program), the statement in line 61 is executed. • If the user entered any choice other than 1, 2, 3, or 4, the else clause in lines 63–67 executes, displaying an error message. 4.11 Focus on Software Engineering: Validating User Input CONCEPT: As long as the user of a program enters bad input, the program will produce bad output. Programs should be written to filter out bad input. Perhaps the most famous saying of the computer world is “Garbage in, garbage out.” The integrity of a program’s output is only as good as its input, so you should try to make sure garbage does not go into your programs. Input validation is the process of..."
4.12 Comparing Characters and Strings,226,"4.12 Comparing Characters and Strings 195 4.12 Comparing Characters and Strings CONCEPT: Relational operators can also be used to compare characters and string objects. Earlier in this chapter you learned to use relational operators to compare numeric values. They can also be used to compare characters and string objects. Comparing Characters As you learned in Chapter 3 , characters are actually stored in memory as integers. On most systems, this integer is the ASCII value of the character. For example, the letter ‘A’ is repre- sented by the number 65, the letter ‘B’ is represented by the number 66, and so on. Table 4-11 shows the ASCII numbers that correspond to some of the commonly used characters. Table 4-11 ASCII Values of Commonly Used Characters Character ASCII Value ‘0’ – ‘9’ 48 – 57 ‘A’ – ‘Z’ 65 – 90 ‘a’ – ‘z’ 97 – 122 blank 32 period 46 Notice that every character, even the blank, has an ASCII code associated with it. Notice also that the ASCII code of a character represent..."
4.13 The Conditional Operator,230,"4.13 The Conditional Operator 199 4.13 The Conditional Operator CONCEPT: You can use the conditional operator to create short expressions that work like if/else statements. The conditional operator is powerful and unique. It provides a shorthand method of expressing a simple if/else statement. The operator consists of the question-mark (?) and the colon (:). Its format is: expression ? expression : expression; Here is an example of a statement using the conditional operator: x < 0 ? y = 10 : z = 20; The statement above is called a conditional expression and consists of three sub-expressions separated by the ? and : symbols. The expressions are x < 0 , y = 10 , and z = 20 , as illustrated here: x < 0 ? y = 10 : z = 20; NOTE: Since it takes three operands, the conditional operator is considered a ternary operator. The conditional expression above performs the same operation as the following if/else statement: if (x < 0) y = 10; else z = 20; The part of the conditional expression that ..."
4.14 The switch Statement,233,"else statement. A) j = k > 90 ? 57 : 12; B) factor = x >= 10 ? y * 22 : y * 35; C) total += count == 1 ? sales : count * sales; D) cout << (((num % 2) == 0) ? ""Even \ n"" : ""Odd\n""); 4.26 What will the following program display? #include <iostream> using namespace std; int main() { const int UPPER = 8, LOWER = 2; int num1, num2, num3 = 12, num4 = 3; num1 = num3 < num4 ? UPPER : LOWER; num2 = num4 > UPPER ? num3 : LOWER; cout << num1 << "" "" << num2 << endl; return 0; } 4.14 The switch Statement CONCEPT: The switch statement lets the value of a variable or expression determine where the program will branch. A branch occurs when one part of a program causes another part to execute. The if/else if statement allows your program to branch into one of several possible paths. It performs a series of tests (usually relational) and branches when one of these tests is true. The switch statement is a similar mechanism. It, however, tests the value of an integer expression and then uses that valu..."
Review Questions and Exercises,245,"Review Questions and Exercises Short Answer 1. Describe the difference between the if/else if statement and a series of if statements. 2. In an if/else if statement, what is the purpose of a trailing else ? 3. What is a flag and how does it work? 4. Can an if statement test expressions other than relational expressions? Explain. 5. Briefly describe how the && operator works. 6. Briefly describe how the || operator works. 7. Why are the relational operators called relational? 8. Why do most programmers indent the conditionally executed statements in a decision structure? Fill-in-the-Blank 9. An expression using the greater-than, less-than, greater-than-or-equal to, less-than-or- equal-to, equal, or not-equal to operator is called a(n) __________ expression. 10. A relational expression is either __________ or __________. 11. The value of a relational expression is 0 if the expression is __________ or 1 if the expression is __________. 12. The if statement regards an expression with th..."
5.1 The Increment and Decrement Operators,258,"The Increment and Decrement Operators CONCEPT: ++ and −− are operators that add and subtract 1 from their operands. To increment a value means to increase it by one, and to decrement a value means to decrease it by one. Both of the following statements increment the variable num : num = num + 1; num += 1; And num is decremented in both of the following statements: num = num − 1; num −= 1; C++ provides a set of simple unary operators designed just for incrementing and decrement- ing variables. The increment operator is ++ , and the decrement operator is −− . The following statement uses the ++ operator to increment num : num++; And the following statement decrements num : num−−; Loops and Files 5 TOPICS 5.1 The Increment and Decrement Operators 5.2 Introduction to Loops: The while Loop 5.3 Using the while Loop for Input Validation 5.4 Counters 5.5 The do-while Loop 5.6 The for Loop 5.7 Keeping a Running Total 5.8 Sentinels 5.9 Focus on Software Engineering: Deciding Which Loop to Use..."
5.2 Introduction to Loops: The while Loop,263,"Introduction to Loops: The while Loop CONCEPT: A loop is part of a program that repeats. Chapter 4 introduced the concept of control structures, which direct the flow of a pro- gram. A loop is a control structure that causes a statement or group of statements to repeat. C++ has three looping control structures: the while loop, the do-while loop, and the for loop. The difference between these structures is how they control the repetition. The while Loop The while loop has two important parts: (1) an expression that is tested for a true or false value, and (2) a statement or block that is repeated as long as the expression is true. Figure 5-1 shows the logic of a while loop. VideoNote The while Loop 5.2 Introduction to Loops: The while Loop 233 Here is the general format of the while loop: while ( expression ) statement; In the general format, expression is any expression that can be evaluated as true or false, and statement is any valid C++ statement. The first line shown in the form..."
5.3 Using the while Loop for Input Validation,270,"5.3 Using the while Loop for Input Validation 239 5.3 Using the while Loop for Input Validation CONCEPT: The while loop can be used to create input routines that repeat until acceptable data is entered. Perhaps the most famous saying of the computer industry is “garbage in, garbage out.” The integrity of a program’s output is only as good as its input, so you should try to make sure garbage does not go into your programs. Input validation is the process of inspecting data given to a program by the user and determining if it is valid. A good program should give clear instructions about the kind of input that is acceptable and not assume the user has followed those instructions. The while loop is especially useful for validating input. If an invalid value is entered, a loop can require that the user reenter it as many times as necessary. For example, the following loop asks for a number in the range of 1 through 100: cout << ""Enter a number in the range 1-100: ""; cin >> number; while ..."
5.4 Counters,272,"5.4 Counters 241 47 48 // Calculate the number of teams. 49 numTeams = players / teamPlayers; 50 51 // Calculate the number of leftover players. 52 leftOver = players % teamPlayers; 53 54 // Display the results. 55 cout << ""There will be "" << numTeams << "" teams with "" 56 << leftOver << "" players left over.\n""; 57 return 0; 58 } Program Output with Example Input Shown in Bold How many players do you wish per team? 4 [Enter] You should have at least 9 but no more than 15 per team. How many players do you wish per team? 12 [Enter] How many players are available? −142 [Enter] Please enter 0 or greater: 142 [Enter] There will be 11 teams with 10 players left over. Checkpoint 5.2 Write an input validation loop that asks the user to enter a number in the range of 10 through 25. 5.3 Write an input validation loop that asks the user to enter ‘Y’, ‘y’, ‘N’, or ‘n’. 5.4 Write an input validation loop that asks the user to enter “Yes” or “No”. 5.4 Counters CONCEPT: A counter is a variable that..."
5.5 The do-while Loop,273,"The do-while Loop CONCEPT: The do-while loop is a posttest loop, which means its expression is tested after each iteration. The do-while loop looks something like an inverted while loop. Here is the do-while loop’s format when the body of the loop contains only a single statement: do statement ; while ( expression ); 5.5 The do-while Loop 243 NOTE: The do-while loop must be terminated with a semicolon. Here is the format of the do-while loop when the body of the loop contains multiple statements: do { statement ; statement ; // Place as many statements here // as necessary. } while ( expression ); The do-while loop is a posttest loop. This means it does not test its expression until it has completed an iteration. As a result, the do-while loop always performs at least one itera- tion, even if the expression is false to begin with. This differs from the behavior of a while loop, which you will recall is a pretest loop. For example, in the following while loop the cout statement will ..."
5.6 The for Loop,278,"5.6 The for Loop 247 B) int v = 10; do cout << v << end1; while (v < 5); C) int count = 0, number = 0, limit = 4; do { number += 2; count++; } while (count < limit); cout << number << "" "" << count << endl; 5.6 The for Loop CONCEPT: The for loop is ideal for performing a known number of iterations. In general, there are two categories of loops: conditional loops and count-controlled loops. A conditional loop executes as long as a particular condition exists. For example, an input validation loop executes as long as the input value is invalid. When you write a conditional loop, you have no way of knowing the number of times it will iterate. Sometimes you know the exact number of iterations that a loop must perform. A loop that repeats a specific number of times is known as a count-controlled loop. For example, if a loop asks the user to enter the sales amounts for each month in the year, it will iterate twelve times. In essence, the loop counts to twelve and asks the user to enter a s..."
5.7 Keeping a Running Total,288,"5.7 Keeping a Running Total 257 Checkpoint 5.6 Name the three expressions that appear inside the parentheses in the for loop’s header. 5.7 You want to write a for loop that displays “I love to program” 50 times. Assume that you will use a counter variable named count . A) What initialization expression will you use? B) What test expression will you use? C) What update expression will you use? D) Write the loop. 5.8 What will the following program segments display? A) for (int count = 0; count < 6; count++) cout << (count + count); B) for (int value = −5; value < 5; value++) cout << value; C) int x; for (x = 5; x <= 14; x += 3) cout << x << endl; cout << x << endl; 5.9 Write a for loop that displays your name 10 times. 5.10 Write a for loop that displays all of the odd numbers, 1 through 49. 5.11 Write a for loop that displays every fifth number, zero through 100. 5.7 Keeping a Running Total CONCEPT: A running total is a sum of numbers that accumulates with each iteration of a loop. ..."
5.8 Sentinels,291,"Sentinels CONCEPT: A sentinel is a special value that marks the end of a list of values. Program 5-12 , in the previous section, requires the user to know in advance the number of days he or she wishes to enter sales figures for. Sometimes the user has a list that is very long and doesn’t know how many items there are. In other cases, the user might be entering several lists, and it is impractical to require that every item in every list be counted. A technique that can be used in these situations is to ask the user to enter a sentinel at the end of the list. A sentinel is a special value that cannot be mistaken as a member of the list and signals that there are no more values to be entered. When the user enters the sentinel, the loop terminates. Program 5-13 calculates the total points earned by a soccer team over a series of games. It allows the user to enter the series of game points, then −1 to signal the end of the list. Program 5-13 1 // This program calculates the total numbe..."
5.9 Focus on Software Engineering: Deciding Which Loop to Use,292,"5.9 Focus on Software Engineering: Deciding Which Loop to Use 261 Program Output with Example Input Shown in Bold Enter the number of points your team has earned so far in the season, then enter −1 when finished. Enter the points for game 1: 7 [Enter] Enter the points for game 2: 9 [Enter] Enter the points for game 3: 4 [Enter] Enter the points for game 4: 6 [Enter] Enter the points for game 5: 8 [Enter] Enter the points for game 6: −1 [Enter] The total points are 34 The value 1 was chosen for the sentinel in this program because it is not possible for a team to score negative points. Notice that this program performs a priming read in line 18 to get the first value. This makes it possible for the loop to immediately terminate if the user enters 1 as the first value. Also note that the sentinel value is not included in the running total. Checkpoint 5.12 Write a for loop that repeats seven times, asking the user to enter a number. The loop should also calculate the sum of the numbe..."
5.10 Nested Loops,293,"5.10 Nested Loops CONCEPT: A loop that is inside another loop is called a nested loop . A nested loop is a loop that appears inside another loop. A clock is a good example of something that works like a nested loop. The second hand, minute hand, and hour hand all spin around the face of the clock. Each time the hour hand increments, the minute hand increments 60 times. Each time the minute hand increments, the second hand increments 60 times. Here is a program segment with a for loop that partially simulates a digital clock. It dis- plays the seconds from 0 to 59: cout << fixed << right; cout.fill('0'); for (int seconds = 0; seconds < 60; seconds++) cout << setw(2) << seconds << endl; NOTE: The fill member function of cout changes the fill character, which is a space by default. In the program segment above, the fill function causes a zero to be printed in front of all single digit numbers. We can add a minutes variable and nest the loop above inside another loop that cycles through..."
5.11 Using Files for Data Storage,296,"5.11 Using Files for Data Storage 265 5.11 Using Files for Data Storage CONCEPT: When a program needs to save data for later use, it writes the data in a file. The data can then be read from the file at a later time. The programs you have written so far require the user to reenter data each time the program runs, because data kept in variables and control properties is stored in RAM and disappears once the program stops running. If a program is to retain data between the times it runs, it must have a way of saving it. Data is saved in a file, which is usually stored on a computer’s disk. Once the data is saved in a file, it will remain there after the program stops running. Data that is stored in a file can be then retrieved and used at a later time. Most of the commercial software that you use on a day-to-day basis store data in files. The following are a few examples. • Word processors: Word processing programs are used to write letters, memos, reports, and other documents. The do..."
5.12 Optional Topics: Breaking and Continuing a Loop,315,"5.12 Optional Topics: Breaking and Continuing a Loop CONCEPT: The break statement causes a loop to terminate early. The continue statement causes a loop to stop its current iteration and begin the next one. WARNING! Use the break and continue statements with great caution. Because they bypass the normal condition that controls the loop’s iterations, these statements make code difficult to understand and debug. For this reason, you should avoid using break and continue whenever possible. However, because they are part of the C++ language, we discuss them briefly in this section. 5.12 Optional Topics: Breaking and Continuing a Loop 285 Sometimes it’s necessary to stop a loop before it goes through all its iterations. The break statement, which was used with switch in Chapter 4 , can also be placed inside a loop. When it is encountered, the loop stops, and the program jumps to the statement immedi- ately following the loop. The while loop in the following program segment appears to exe..."
Review Questions and Exercises,319,"Review Questions and Exercises Short Answer 1. Why should you indent the statements in the body of a loop? 2. Describe the difference between pretest loops and posttest loops. 3. Why are the statements in the body of a loop called conditionally executed statements? 4. What is the difference between the while loop and the do-while loop? 5. Which loop should you use in situations where you wish the loop to repeat until the test expression is false, and the loop should not execute if the test expression is false to begin with? 6. Which loop should you use in situations where you wish the loop to repeat until the test expression is false, but the loop should execute at least one time? 7. Which loop should you use when you know the number of required iterations? 8. Why is it critical that counter variables be properly initialized? 9. Why is it critical that accumulator variables be properly initialized? 10. Why should you be careful not to place a statement in the body of a for loop that..."
CHAPTER 6 Functions,330,"functions. Functions are commonly used to break a problem down into small manageable pieces. Instead of writing one long function that contains all of the statements necessary to solve a problem, several small functions that each solve a specific part of the problem can be written. These small functions can then be executed in the desired order to solve the prob- lem. This approach is sometimes called divide and conquer because a large problem is Functions 6 TOPICS 6.1"
6.1 Focus on Software Engineering: Modular Programming,330,"Focus on Software Engineering: Modular Programming CONCEPT: A program may be broken up into manageable functions. A function is a collection of statements that performs a specific task. So far you have experienced functions in two ways: (1) you have created a function named main in every program you’ve written, and (2) you have used library functions such as pow and strcmp . In this chapter you will learn how to create your own functions that can be used like library functions. Functions are commonly used to break a problem down into small manageable pieces. Instead of writing one long function that contains all of the statements necessary to solve a problem, several small functions that each solve a specific part of the problem can be written. These small functions can then be executed in the desired order to solve the prob- lem. This approach is sometimes called divide and conquer because a large problem is Functions 6 TOPICS 6.1 Focus on Software Engineering: Modular Programming ..."
6.2 Defining and Calling Functions,331,"Defining and Calling Functions CONCEPT: A function call is a statement that causes a function to execute. A function definition contains the statements that make up the function. main function function 2 function 3 function 4 int main() { statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; statement; } int main() { statement; statement; statement; } void function2() { statement; statement; statement; } void function3() { statement; statement; statement; } void function4() { statement; statement; statement; } This program has one long, complex function containing all of the statements necessary to solve a problem. In this program the problem has been divided into smaller problems, each of which is handled by a separate function. Figure 6-1 divided into several smaller problems that are ..."
6.3 Function Prototypes,340,"6.3 Function Prototypes 309 int main() { double salary; int years; cout << ""This program will determine if you qualify\n""; cout << ""for our credit card.\n""; cout << ""What is your annual salary? ""; cin >> salary; cout << ""How many years have you worked at your ""; cout << ""current job? ""; cin >> years; if (salary >= 17000.0 && years >= 2) qualify(); else noQualify(); return 0; } 6.3 Function Prototypes CONCEPT: A function prototype eliminates the need to place a function definition before all calls to the function. Before the compiler encounters a call to a particular function, it must already know the function’s return type, the number of parameters it uses, and the type of each parameter. (You will learn how to use parameters in the next section.) One way of ensuring that the compiler has this information is to place the function defini- tion before all calls to that function. This was the approach taken in Programs 6-1 , 6-2 , 6-3 , and 6-4 . Another method is to declare the functi..."
6.4 Sending Data into a Function,342,"6.4 Sending Data into a Function 311 6.4 Sending Data into a Function CONCEPT: When a function is called, the program may send values into the function. Values that are sent into a function are called arguments . You’re already familiar with how to use arguments in a function call. In the following statement the function pow is being called and two arguments, 2.0 and 4.0, are passed to it: result = pow(2.0, 4.0); By using parameters , you can design your own functions that accept data this way. A parameter is a special variable that holds a value being passed into a function. Here is the definition of a function that uses a parameter: void displayValue(int num) { cout << ""The value is "" << num << endl; } Notice the integer variable definition inside the parentheses (int num) . The variable num is a parameter. This enables the function displayValue to accept an integer value as an argument. Program 6-6 is a complete program using this function. VideoNote Functions and Arguments NOTE:..."
6.5 Passing Data by Value,347,"Passing Data by Value CONCEPT: When an argument is passed into a parameter, only a copy of the argument’s value is passed. Changes to the parameter do not affect the original argument. As you’ve seen in this chapter, parameters are special-purpose variables that are defined inside the parentheses of a function definition. They are separate and distinct from the argu- ments that are listed inside the parentheses of a function call. The values that are stored in the parameter variables are copies of the arguments. Normally, when a parameter’s value is changed inside a function, it has no effect on the original argument. Program 6-9 dem- onstrates this concept. Program 6-9 1 // This program demonstrates that changes to a function parameter 2 // have no effect on the original argument. 3 #include <iostream> 4 using namespace std; 5 6 // Function Prototype 7 void changeMe(int); 8 9 int main() 10 { 11 int number = 12; 12 13 // Display the value in number. 14 cout << ""number is "" << number..."
6.6 Focus on Software Engineering: Using Functions in a Menu-Driven Program,349,"Focus on Software Engineering: Using Functions in a Menu-Driven Program CONCEPT: Functions are ideal for use in menu-driven programs. When the user selects an item from a menu, the program can call the appropriate function. In Chapters 4 and 5 you saw a menu-driven program that calculates the charges for a health club membership. Program 6-10 shows the program redesigned as a modular program. A modular program is broken up into functions that perform specific tasks. Program 6-10 1 // This is a menu-driven program that makes a function call 2 // for each selection the user makes. 3 #include <iostream> 4 #include <iomanip> 5 using namespace std; 6 7 // Function prototypes 8 void showMenu(); 9 void showFees(double, int); 10 11 int main() 12 { 13 int choice; // To hold a menu choice 14 int months; // To hold a number of months 15 16 // Constants for the menu choices 17 const int ADULT_CHOICE = 1, 18 CHILD_CHOICE = 2, 19 SENIOR_CHOICE = 3, 20 QUIT_CHOICE = 4; 21 22 // Constants for membe..."
6.7 The return Statement,353,"The return Statement CONCEPT: The return statement causes a function to end immediately. When the last statement in a void function has finished executing, the function terminates and the program returns to the statement following the function call. It’s possible, however, to force a function to return before the last statement has been executed. When the return statement is encountered, the function immediately terminates and control of the program returns to the statement that called the function. This is demonstrated in Program 6-11 . The function divide shows the quotient of arg1 divided by arg2 . If arg2 is set to zero, the function returns. 6.7 The return Statement 323 Program 6-11 1 // This program uses a function to perform division. If division 2 // by zero is detected, the function returns. 3 #include <iostream> 4 using namespace std; 5 6 // Function prototype. 7 void divide(double, double); 8 9 int main() 10 { 11 double num1, num2; 12 13 cout << ""Enter two numbers and I w..."
6.8 Returning a Value from a Function,355,"Returning a Value from a Function CONCEPT: A function may send a value back to the part of the program that called the function. You’ve seen that data may be passed into a function by way of parameter variables. Data may also be returned from a function, back to the statement that called it. Functions that return a value are appropriately known as value-returning functions . The pow function, which you have already seen, is an example of a value-returning function. Here is an example: double x; x = pow(4.0, 2.0); The second line in this code calls the pow function, passing 4.0 and 2.0 as arguments. The function calculates the value of 4.0 raised to the power of 2.0 and returns that value. The value, which is 16.0, is assigned to the x variable by the = operator. Although several arguments may be passed into a function, only one value may be returned from it. Think of a function as having multiple communication channels for receiving data (parameters), but only one channel for sendin..."
6.9 Returning a Boolean Value,363,"Returning a Boolean Value CONCEPT: Functions may return true or false values. Frequently there is a need for a function that tests an argument and returns a true or false value indicating whether or not a condition exists. Such a function would return a bool value. For example, the following function accepts an int argument and returns true if the argument is within the range of 1 through 100, or false otherwise. bool isValid(int number) { bool status; if (number >= 1 && number <= 100) status = true; else status = false; return status; } 332 Chapter 6 Functions 6.9 Returning a Boolean Value 333 The following code shows an if / else statement that uses a call to the function: int value = 20; if (isValid(value)) cout << ""The value is within range.\n""; else cout << ""The value is out of range.\n""; When this code executes, the message “The value is within range.” will be displayed. Program 6-15 shows another example. This program has a function named isEven which returns true if its argu..."
6.10 Local and Global Variables,365,"6.10 Local and Global Variables CONCEPT: A local variable is defined inside a function and is not accessible outside the function. A global variable is defined outside all functions and is accessible to all functions in its scope. Local Variables Variables defined inside a function are local to that function. They are hidden from the statements in other functions, which normally cannot access them. Program 6-16 shows that because the variables defined in a function are hidden, other functions may have sepa- rate, distinct variables with the same name. Program 6-16 1 // This program shows that variables defined in a function 2 // are hidden from other functions. 3 #include <iostream> 4 using namespace std; 5 6 void anotherFunction(); // Function prototype 6.10 Local and Global Variables 335 7 8 int main() 9 { 10 int num = 1; // Local variable 11 12 cout << ""In main, num is "" << num << endl; 13 anotherFunction(); 14 cout << ""Back in main, num is "" << num << endl; 15 return 0; 16 } 17 ..."
6.11 Static Local Variables,373,"6.11 Static Local Variables If a function is called more than once in a program, the values stored in the function’s local variables do not persist between function calls. This is because the local variables are destroyed when the function terminates and are then re-created when the function starts again. This is shown in Program 6-21 . Program 6-21 1 // This program shows that local variables do not retain 2 // their values between function calls. 3 #include <iostream> 4 using namespace std; 5 6 // Function prototype 7 void showLocal(); 8 9 int main() 10 { 11 showLocal(); 12 showLocal(); 13 return 0; 14 } 15 16 //*********************************************************** 17 // Definition of function showLocal. * 18 // The initial value of localNum, which is 5, is displayed. * 19 // The value of localNum is then changed to 99 before the * 20 // function returns. * 21 //*********************************************************** 22 23 void showLocal() 24 { 25 int localNum = 5; // Lo..."
6.12 Default Arguments,376,"6.12 Default Arguments 345 int var = 100; cout << var << endl; myFunc(); cout << var << endl; return 0; } // Definition of function myFunc void myFunc() { int var = 50; cout << var << endl; } 6.18 What is the output of the following program? #include <iostream> using namespace std; void showVar(); // Function prototype int main() { for (int count = 0; count < 10; count++) showVar(); return 0; } // Definition of function showVar void showVar() { static int var = 10; cout << var << endl; var++; } 6.12 Default Arguments CONCEPT: Default arguments are passed to parameters automatically if no argument is provided in the function call. It’s possible to assign default arguments to function parameters. A default argument is passed to the parameter when the actual argument is left out of the function call. The default arguments are usually listed in the function prototype. Here is an example: void showArea(double = 20.0, double = 10.0); Default arguments are literal values or constants with ..."
6.13 Using Reference Variables as Parameters,379,"6.13 Using Reference Variables as Parameters CONCEPT: When used as parameters, reference variables allow a function to access the parameter’s original argument. Changes to the parameter are also made to the argument. Earlier you saw that arguments are normally passed to a function by value, and that the function cannot change the source of the argument. C++ provides a special type of variable 6.13 Using Reference Variables as Parameters 349 called a reference variable that, when used as a function parameter, allows access to the original argument. A reference variable is an alias for another variable. Any changes made to the reference vari- able are actually performed on the variable for which it is an alias. By using a reference vari- able as a parameter, a function may change a variable that is defined in another function. Reference variables are defined like regular variables, except you place an ampersand (&) in front of the name. For example, the following function definition m..."
6.14 Overloading Functions,385,"6.14 Overloading Functions CONCEPT: Two or more functions may have the same name, as long as their parameter lists are different. Sometimes you will create two or more functions that perform the same operation, but use a different set of parameters or parameters of different data types. For instance, in Program 6-13 there is a square function that uses a double parameter. But, suppose you also wanted a square function that works exclusively with integers, accepting an int as its argument. Both functions would do the same thing: return the square of their argument. The only difference is the data type involved in the operation. If you were to use both these functions in the same program, you could assign a unique name to each function. For example, the function that squares an int might be named squareInt , and the one that squares a double might be named squareDouble . C++, however, allows you to overload function names. That means you may assign the same name to multiple functions,..."
6.15 The exit() Function,389,"6.15 The exit() Function CONCEPT: The exit() function causes a program to terminate, regardless of which function or control mechanism is executing. A C++ program stops executing when the return statement in function main is encoun- tered. When other functions end, however, the program does not stop. Control of the program goes back to the place immediately following the function call. Sometimes, rare circumstances make it necessary to terminate a program in a function other than main . To accomplish this, the exit function is used. When the exit function is called, it causes the program to stop, regardless of which func- tion contains the call. Program 6-29 demonstrates its use. 6.15 The exit() Function 359 Program 6-29 1 // This program shows how the exit function causes a program 2 // to stop executing. 3 #include <iostream> 4 #include <cstdlib> // Needed for the exit function 5 using namespace std; 6 7 void function(); // Function prototype 8 9 int main() 10 { 11 function(); 12 ..."
6.16 Stubs and Drivers,392,"6.16 Stubs and Drivers 361 6.16 Stubs and Drivers Stubs and drivers are very helpful tools for testing and debugging programs that use func- tions. They allow you to test the individual functions in a program, in isolation from the parts of the program that call the functions. A stub is a dummy function that is called instead of the actual function it represents. It usually displays a test message acknowledging that it was called, and nothing more. For example, if a stub were used for the showFees function in Program 6-10 (the modular health club membership program), it might look like this: void showFees(double memberRate, int months) { cout << ""The showFees function was called with "" << ""the following arguments:\n"" << ""memberRate: "" << memberRate << endl << ""months: "" << months << endl; } The following is an example output of the program if it were run with the stub instead of the actual showFees function. (A version of the health club program using this stub func- tion is availab..."
Review Questions and Exercises,394,"Review Questions and Exercises 363 Review Questions and Exercises Short Answer 1. Why do local variables lose their values between calls to the function in which they are defined? 2. What is the difference between an argument and a parameter variable? 3. Where do you define parameter variables? 4. If you are writing a function that accepts an argument and you want to make sure the function cannot change the value of the argument, what do you do? 5. When a function accepts multiple arguments, does it matter in what order the argu- ments are passed? 6. How do you return a value from a function? 7. What is the advantage of breaking your application’s code into several small procedures? 8. How would a static local variable be useful? 9. Give an example where passing an argument by reference would be useful. Fill-in-the-Blank 10. The _________ is the part of a function definition that shows the function name, return type, and parameter list. 11. If a function doesn’t return a value, the ..."
7.1 Arrays Hold Multiple Values,406,Arrays Hold Multiple Values CONCEPT: An array allows you to store and work with multiple values of the same data type. The variables you have worked with so far are designed to hold only one value at a time. Each of the variable definitions in Figure 7-1 causes only enough memory to be reserved to hold one value of the specified data type. Arrays 7 TOPICS 7.1 Arrays Hold Multiple Values 7.2 Accessing Array Elements 7.3 No Bounds Checking in C++ 7.4 Array Initialization 7.5 The Range-Based for Loop 7.6 Processing Array Contents 7.7 Focus on Software Engineering: Using Parallel Arrays 7.8 Arrays as Function Arguments 7.9 Two-Dimensional Arrays 7.10 Arrays with Three or More Dimensions 7.11 Focus on Problem Solving and Program Design: A Case Study 7.12 If You Plan to Continue in Computer Science: Introduction to the STL vector C H A P T E R int count; Enough memory for 1 int 12314 float price; Enough memory for 1 float 56.981 char letter; Enough memory for 1 char A Figure 7-1
7.2 Accessing Array Elements,408,"7.2 Accessing Array Elements 377 The size of an array can be calculated by multiplying the size of an individual element by the number of elements in the array. Table 7-1 shows the typical sizes of various arrays. Table 7-1 Array Definition Number of Elements Size of Each Element Size of the Array char letters[25]; 25 1 byte 25 bytes short rings[100]; 100 2 bytes 200 bytes int miles[84]; 84 4 bytes 336 bytes float temp[12]; 12 4 bytes 48 bytes double distance[1000]; 1000 8 bytes 8000 bytes 7.2 Accessing Array Elements CONCEPT: The individual elements of an array are assigned unique subscripts. These subscripts are used to access the elements. Even though an entire array has only one name, the elements may be accessed and used as individual variables. This is possible because each element is assigned a number known as a subscript . A subscript is used as an index to pinpoint a specific element within an array. The first element is assigned the subscript 0, the second element is assig..."
7.3 No Bounds Checking in C++,415,"No Bounds Checking in C++ CONCEPT: C++ does not prevent you from overwriting an array’s bounds. C++ is a popular language for software developers who have to write fast, efficient code. To increase runtime efficiency, C++ does not provide many of the common safeguards to pre- vent unsafe memory access found in other languages. For example, C++ does not perform array bounds checking. This means you can write programs with subscripts that go beyond the boundaries of a particular array. Program 7-5 demonstrates this capability. 7.3 No Bounds Checking in C++ 385 Program 7-5 1 // This program unsafely accesses an area of memory by writing 2 // values beyond an array's boundary. 3 // WARNING: If you compile and run this program, it could crash. 4 #include <iostream> 5 using namespace std; 6 7 int main() 8 { 9 const int SIZE = 3; // Constant for the array size 10 int values[SIZE]; // An array of 3 integers 11 int count; // Loop counter variable 12 13 // Attempt to store five numbers in the..."
7.4 Array Initialization,418,"7.4 Array Initialization 387 Checkpoint 7.1 Define the following arrays: A) empNums , a 100-element array of int s B) payRates , a 25-element array of float s C) miles , a 14-element array of long s D) cityName , a 26-element array of string objects E) lightYears , a 1,000-element array of double s 7.2 What’s wrong with the following array definitions? int readings[-1]; float measurements[4.5]; int size; string names[size]; 7.3 What would the valid subscript values be in a four-element array of double s? 7.4 What is the difference between an array’s size declarator and a subscript? 7.5 What is “array bounds checking”? Does C++ perform it? 7.6 What is the output of the following code? int values[5], count; for (count = 0; count < 5; count++) values[count] = count + 1; for (count = 0; count < 5; count++) cout << values[count] << endl; 7.7 The following program skeleton contains a 20-element array of int s called fish . When completed, the program should ask how many fish were caught b..."
7.5 The Range-Based for Loop,423,"The Range-Based for Loop CONCEPT: The range-based for loop is a loop that iterates once for each element in an array. Each time the loop iterates, it copies an element from the array to a variable. The range-based for loop was introduced in C++ 11. C++ 11 provides a specialized version of the for loop that, in many circumstances, simpli- fies array processing. It is known as the range-based for loop . When you use the range- based for loop with an array, the loop automatically iterates once for each element in the array. For example, if you use the range-based for loop with an eight-element array, the loop will iterate eight times. Because the range-based for loop automatically knows the number of elements in an array, you do not have to use a counter variable to control its iterations, as with a regular for loop. Additionally, you do not have to worry about step- ping outside the bounds of an array when you use the range-based for loop. The range-based for loop is designed to work ..."
7.7 Focus on Software Engineering: Using Parallel Arrays,435,"Focus on Software Engineering: Using Parallel Arrays CONCEPT: By using the same subscript, you can build relationships between data stored in two or more arrays. Sometimes it’s useful to store related data in two or more arrays. It’s especially useful when the related data is of unlike types. For example, Program 7-15 is another variation of the payroll program. It uses two arrays: one to store the hours worked by each employee (as int s), and another to store each employee’s hourly pay rate (as double s). Program 7-15 1 // This program uses two parallel arrays: one for hours 2 // worked and one for pay rate. 3 #include <iostream> 7.7 Focus on Software Engineering: Using Parallel Arrays 405 4 #include <iomanip> 5 using namespace std; 6 7 int main() 8 { 9 const int NUM_EMPLOYEES = 5; // Number of employees 10 int hours[NUM_EMPLOYEES]; // Holds hours worked 11 double payRate[NUM_EMPLOYEES]; // Holds pay rates 12 13 // Input the hours worked and the hourly pay rate. 14 cout << ""Enter t..."
7.8 Arrays as Function Arguments,438,"7.8 Arrays as Function Arguments 407 7.11 Given the following array definition: int nums[5] = {1, 2, 3}; What will the following statement display? cout << nums[3]; 7.12 What is the output of the following code? (You may need to use a calculator.) double balance[5] = {100.0, 250.0, 325.0, 500.0, 1100.0}; const double INTRATE = 0.1; cout << fixed << showpoint << setprecision(2); for (int count = 0; count < 5; count++) cout << (balance[count] * INTRATE) << endl; 7.13 What is the output of the following code? (You may need to use a calculator.) const int SIZE = 5; int time[SIZE] = {1, 2, 3, 4, 5}, speed[SIZE] = {18, 4, 27, 52, 100}, dist[SIZE]; for (int count = 0; count < SIZE; count++) dist[count] = time[count] * speed[count]; for (int count = 0; count < SIZE; count++) { cout << time[count] << "" ""; cout << speed[count] << "" ""; cout << dist[count] << endl; } 7.8 Arrays as Function Arguments CONCEPT: To pass an array as an argument to a function, pass the name of the array. Quite often ..."
7.9 Two-Dimensional Arrays,449,"Two-Dimensional Arrays CONCEPT: A two-dimensional array is like several identical arrays put together. It is useful for storing multiple sets of data. An array is useful for storing and working with a set of data. Sometimes, though, it’s nec- essary to work with multiple sets of data. For example, in a grade-averaging program a teacher might record all of one student’s test scores in an array of double s. If the teacher 7.9 Two-Dimensional Arrays 419 has 30 students, that means she’ll need 30 arrays of double s to record the scores for the entire class. Instead of defining 30 individual arrays, however, it would be better to define a two-dimensional array. The arrays that you have studied so far are one-dimensional arrays. They are called one- dimensional because they can only hold one set of data. Two-dimensional arrays, which are sometimes called 2D arrays , can hold multiple sets of data. It’s best to think of a two- dimensional array as having rows and columns of elements, as sh..."
7.10 Arrays with Three or More Dimensions,456,"7.10 Arrays with Three or More Dimensions 425 Notice that the total variable, which is used as an accumulator, is set to zero just before the inner loop executes. This is because the inner loop sums the elements of a row and stores the sum in total . Therefore, the total variable must be set to zero before each iteration of the inner loop. Summing the Columns of a Two-Dimensional Array Sometimes you may need to calculate the sum of each column in a two-dimensional array. In the previous example a two-dimensional array is used to hold a set of test scores for a set of students. Suppose you wish to calculate the class average for each of the test scores. To do this, you calculate the average of each column in the array. This is accomplished with a set of nested loops. The outer loop controls the column subscript and the inner loop controls the row subscript. The inner loop calculates the sum of a column, which is stored in an accumulator. The following code demonstrates. const int NUM..."
7.11 Focus on Problem Solving and Program Design: A Case Study,458,"7.11 Focus on Problem Solving and Program Design: A Case Study 427 7.24 Fill in the table below so it shows the contents of the following array: int table[3][4] = {{2, 3}, {7, 9, 2}, {1}}; 7.25 Write a function called displayArray7 . The function should accept a two- dimensional array as an argument and display its contents on the screen. The function should work with any of the following arrays: int hours[5][7]; int stamps[8][7]; int autos[12][7]; int cats[50][7]; 7.26 A video rental store keeps DVDs on 50 racks with 10 shelves each. Each shelf holds 25 DVDs. Define a three-dimensional array large enough to represent the store’s storage system. 7.11 Focus on Problem Solving and Program Design: A Case Study The National Commerce Bank has hired you as a contract programmer. Your first assign- ment is to write a function that will be used by the bank’s automated teller machines (ATMs) to validate a customer’s personal identification number (PIN). Your function will be incorporated int..."
7.12 If You Plan to Continue in Computer Science: Introduction to the STL vector,460,"7.12 If You Plan to Continue in Computer Science: Introduction to the STL vector 429 34 //****************************************************************** 35 // The following function accepts two int arrays. The arrays are * 36 // compared. If they contain the same values, true is returned. * 37 // If they contain different values, false is returned. * 38 //****************************************************************** 39 40 bool testPIN(const int custPIN[], const int databasePIN[], int size) 41 { 42 for (int index = 0; index < size; index++) 43 { 44 if (custPIN[index] != databasePIN[index]) 45 return false; // We've found two different values. 46 } 47 return true; // If we make it this far, the values are the same. 48 } Program Output SUCCESS: pin1 and pin2 are different. SUCCESS: pin1 and pin3 are different. SUCCESS: pin1 and pin1 report to be the same. Case Study: See the Intersection of Sets Case Study on the book’s companion Web site at www.pearsonhighered.com/gaddis . 7...."
Review Questions and Exercises,474,"Review Questions and Exercises 443 Member Function Description resize( elements , value ) Resizes a vector by elements elements. Each of the new ele- ments is initialized with the value in value . Example: vect.resize(5, 1); This statement increases the size of vect by five elements. The five new elements are initialized to the value 1. swap( vector2 ) Swaps the contents of the vector with the contents of vector2 . Example: vect1.swap(vect2); This statement swaps the contents of vect1 and vect2 Checkpoint 7.27 What header file must you #include in order to define vector objects? 7.28 Write a definition statement for a vector named frogs . frogs should be an empty vector of int s. 7.29 Write a definition statement for a vector named lizards . lizards should be a vector of 20 float s. 7.30 Write a definition statement for a vector named toads . toads should be a vector of 100 char s, with each element initialized to 'Z' . 7.31 gators is an empty vector of int s. Write a statement that..."
8.1 Focus on Software Engineering: Introduction to Search Algorithms,488,"Focus on Software Engineering: Introduction to Search Algorithms CONCEPT: A search algorithm is a method of locating a specific item in a larger collection of data. This section discusses two algorithms for searching the contents of an array. It’s very common for programs not only to store and process data stored in arrays, but to search arrays for specific items. This section will show you two methods of searching an array: the linear search and the binary search. Each has its advantages and disadvantages. The Linear Search The linear search is a very simple algorithm. Sometimes called a sequential search , it uses a loop to sequentially step through an array, starting with the first element. It compares each element with the value being searched for and stops when either the value is found or the end of the array is encountered. If the value being searched for is not in the array, the algorithm will unsuccessfully search to the end of the array. Here is the pseudocode for a functi..."
8.2 Focus on Problem Solving and Program Design: A Case Study,494,"8.2 Focus on Problem Solving and Program Design: A Case Study 463 59 { 60 found = true; 61 position = middle; 62 } 63 else if (array[middle] > value) // If value is in lower half 64 last = middle − 1; 65 else 66 first = middle + 1; // If value is in upper half 67 } 68 return position; 69 } Program Output with Example Input Shown in Bold Enter the employee ID you wish to search for: 199 [Enter] That ID is found at element 4 in the array. WARNING! Notice that the array in Program 8-2 is initialized with its values already sorted in ascending order. The binary search algorithm will not work properly unless the values in the array are sorted. The Efficiency of the Binary Search Obviously, the binary search is much more efficient than the linear search. Every time it makes a comparison and fails to find the desired item, it eliminates half of the remaining portion of the array that must be searched. For example, consider an array with 1,000 elements. If the binary search fails to find an..."
8.3 Focus on Software Engineering: Introduction to Sorting Algorithms,501,"Introduction to Sorting Algorithms CONCEPT: Sorting algorithms are used to arrange data into some order. Often the data in an array must be sorted in some order. Customer lists, for instance, are commonly sorted in alphabetical order. Student grades might be sorted from highest to low- est. Product codes could be sorted so all the products of the same color are stored together. To sort the data in an array, the programmer must use an appropriate sorting algorithm . A sorting algorithm is a technique for scanning through an array and rearranging its contents in some specific order. This section will introduce two simple sorting algorithms: the bubble sort and the selection sort . The Bubble Sort The bubble sort is an easy way to arrange data in ascending or descending order . If an array is sorted in ascending order, it means the values in the array are stored from low- est to highest. If the values are sorted in descending order, they are stored from highest to lowest. Let’s see how..."
8.4 Focus on Problem Solving and Program Design: A Case Study,508,"8.4 Focus on Problem Solving and Program Design: A Case Study 477 44 { 45 if (array[index] < minValue) 46 { 47 minValue = array[index]; 48 minIndex = index; 49 } 50 } 51 array[minIndex] = array[startScan]; 52 array[startScan] = minValue; 53 } 54 } 55 56 //************************************************************** 57 // Definition of function showArray. * 58 // This function displays the contents of array. size is the * 59 // number of elements. * 60 //************************************************************** 61 62 void showArray(const int array[], int size) 63 { 64 for (int count = 0; count < size; count++) 65 cout << array[count] << "" ""; 66 cout << endl; 67 } Program Output The unsorted values are 5 7 2 8 9 1 The sorted values are 1 2 5 7 8 9 8.4 Focus on Problem Solving and Program Design: A Case Study Like the previous case study, this is a program developed for the Demetris Leadership Center. Recall that DLC, Inc., publishes books, DVDs, and audio CDs. (See Table 8-1 fo..."
8.5 If You Plan to Continue in Computer Science: Sorting and Searching vectors,516,"8.5 If You Plan to Continue in Computer Science: Sorting and Searching vectors 485 134 totalUnits += units[index]; 135 totalSales += sales[index]; 136 } 137 cout << ""Total Units Sold: "" << totalUnits << endl; 138 cout << ""Total Sales: $"" << totalSales << endl; 139 } Program Output Product Number Sales ---------------------------------- 914 $10903.90 918 $ 9592.15 917 $ 8712.30 919 $ 8594.55 921 $ 7355.40 915 $ 6219.20 922 $ 3593.40 916 $ 2406.65 920 $ 1450.15 Total Units Sold: 3406 Total Sales: $58827.70 8.5 If You Plan to Continue in Computer Science: Sorting and Searching vector s (Continued from Section 7.12) CONCEPT: The sorting and searching algorithms you have studied in this chapter may be applied to STL vectors as well as arrays. Once you have properly defined an STL vector and populated it with values, you may sort and search the vector with the algorithms presented in this chapter. Simply substitute the vector syntax for the array syntax when necessary. Program 8-7 , which..."
Review Questions and Exercises,521,"Review Questions and Exercises Short Answer 1. Why is the linear search also called “sequential search”? 2. If a linear search function is searching for a value that is stored in the last element of a 10,000-element array, how many elements will the search code have to read to locate the value? 3. In an average case involving an array of N elements, how many times will a linear search function have to read the array to locate a specific value? 4. A binary search function is searching for a value that is stored in the middle element of an array. How many times will the function read an element in the array before finding the value? 5. What is the maximum number of comparisons that a binary search function will make when searching for a value in a 1,000-element array? 6. Why is the bubble sort inefficient for large arrays? 7. Why is the selection sort more efficient than the bubble sort on large arrays? Fill-in-the-Blank 8. The _________ search algorithm steps sequentially through an ..."
9.1 Getting the Address of a Variable,526,"Getting the Address of a Variable CONCEPT: The address operator (&) returns the memory address of a variable. Every variable is allocated a section of memory large enough to hold a value of the variable’s data type. On a PC, for instance, it’s common for one byte to be allocated for char s, two bytes for short s, four bytes for int s, long s, and float s, and eight bytes for double s. Each byte of memory has a unique address . A variable’s address is the address of the first byte allocated to that variable. Suppose the following variables are defined in a program: char letter; short number; float amount; Figure 9-1 illustrates how they might be arranged in memory and shows their addresses. Pointers 9 TOPICS 9.1 Getting the Address of a Variable 9.2 Pointer Variables 9.3 The Relationship Between Arrays and Pointers 9.4 Pointer Arithmetic 9.5 Initializing Pointers 9.6 Comparing Pointers 9.7 Pointers as Function Parameters 9.8 Focus on Software Engineering: Dynamic Memory Allocation 9...."
9.2 Pointer Variables,528,"9.2 Pointer Variables 497 Program Output The address of x is 0x8f05 The size of x is 4 bytes The value in x is 25 NOTE: The address of the variable x is displayed in hexadecimal. This is the way addresses are normally shown in C++. 9.2 Pointer Variables CONCEPT: Pointer variables , which are often just called pointers , are designed to hold memory addresses. With pointer variables you can indirectly manipulate data stored in other variables. A pointer variable , which often is just called a pointer , is a special variable that holds a memory address. Just as int variables are designed to hold integers, and double variables are designed to hold floating-point numbers, pointer variables are designed to hold memory addresses. Memory addresses identify specific locations in the computer’s memory. Because a pointer variable holds a memory address, it can be used to hold the location of some other piece of data. This should give you a clue as to why it is called a pointer: It “points” to ..."
9.3 The Relationship Between Arrays and Pointers,535,"The Relationship Between Arrays and Pointers CONCEPT: Array names can be used as constant pointers, and pointers can be used as array names. You learned in Chapter 7 that an array name, without brackets and a subscript, actually represents the starting address of the array. This means that an array name is really a pointer. Program 9-5 illustrates this by showing an array name being used with the indirec- tion operator. Program 9-5 1 // This program shows an array name being dereferenced with the * 2 // operator. 3 #include <iostream> 4 using namespace std; 5 6 int main() 7 { 8 short numbers[] = {10, 20, 30, 40, 50}; 9 10 cout << ""The first element of the array is ""; 11 cout << *numbers << endl; 12 return 0; 13 } Program Output The first element of the array is 10 NOTE: So far you’ve seen three different uses of the asterisk in C++: • As the multiplication operator, in statements such as distance = speed * time; • In the definition of a pointer variable, such as int *ptr = nullptr; ..."
9.4 Pointer Arithmetic,539,"Pointer Arithmetic CONCEPT: Some mathematical operations may be performed on pointers. The contents of pointer variables may be changed with mathematical statements that per- form addition or subtraction. This is demonstrated in Program 9-9 . The first loop incre- ments the pointer variable, stepping it through each element of the array. The second loop decrements the pointer, stepping it through the array backward. 9.4 Pointer Arithmetic 509 Program 9-9 1 // This program uses a pointer to display the contents of an array. 2 #include <iostream> 3 using namespace std; 4 5 int main() 6 { 7 const int SIZE = 8; 8 int set[SIZE] = {5, 10, 15, 20, 25, 30, 35, 40}; 9 int *numPtr = nullptr; // Pointer 10 int count; // Counter variable for loops 11 12 // Make numPtr point to the set array. 13 numPtr = set; 14 15 // Use the pointer to display the array contents. 16 cout << ""The numbers in set are:\n""; 17 for (count = 0; count < SIZE; count++) 18 { 19 cout << *numPtr << "" ""; 20 numPtr++; 21 } 2..."
9.5 Initializing Pointers,541,"Initializing Pointers CONCEPT: Pointers may be initialized with the address of an existing object. Remember that a pointer is designed to point to an object of a specific data type. When a pointer is initialized with an address, it must be the address of an object the pointer can point to. For instance, the following definition of pint is legal because myValue is an integer: int myValue; int *pint = &myValue; The following is also legal because ages is an array of integers: int ages[20]; int *pint = ages; But the following definition of pint is illegal because myFloat is not an int : float myFloat; int *pint = &myFloat; // Illegal! Pointers may be defined in the same statement as other variables of the same type. The following statement defines an integer variable, myValue , and then defines a pointer, pint , which is initialized with the address of myValue : int myValue, *pint = &myValue; And the following statement defines an array, readings , and a pointer, marker , which is init..."
9.6 Comparing Pointers,542,"9.6 Comparing Pointers 511 *ptr *= 10; ptr = &y; *ptr *= 5; ptr = &z; *ptr *= 2; cout << x << "" "" << y << "" "" << z << endl; 9.5 Rewrite the following loop so it uses pointer notation (with the indirection opera- tor) instead of subscript notation. for (int x = 0; x < 100; x++) cout << arr[x] << endl; 9.6 Assume ptr is a pointer to an int and holds the address 12000. On a system with 4-byte integers, what address will be in ptr after the following statement? ptr += 10; 9.7 Assume pint is a pointer variable. Is each of the following statements valid or invalid? If any is invalid, why? A) pint++; B) −−pint; C) pint /= 2; D) pint *= 4; E) pint += x; // Assume x is an int. 9.8 Is each of the following definitions valid or invalid? If any is invalid, why? A) int ivar; int *iptr = &ivar; B) int ivar, *iptr = &ivar; C) float fvar; int *iptr = &fvar; D) int nums[50], *iptr = nums; E) int *iptr = &ivar; int ivar; 9.6 Comparing Pointers CONCEPT: If one address comes before another address in m..."
9.7 Pointers as Function Parameters,544,"9.7 Pointers as Function Parameters 513 14 while (nums < &set[7]) 15 { 16 // Advance nums to point to the next element. 17 nums++; 18 // Display the value pointed to by nums. 19 cout << *nums << "" ""; 20 } 21 22 // Display the numbers in reverse order. 23 cout << ""\nThe numbers in set backward are:\n""; 24 cout << *nums << "" ""; // Display first element 25 while (nums > set) 26 { 27 // Move backward to the previous element. 28 nums−−; 29 // Display the value pointed to by nums. 30 cout << *nums << "" ""; 31 } 32 return 0; 33 } Program Output The numbers in set are: 5 10 15 20 25 30 35 40 The numbers in set backward are: 40 35 30 25 20 15 10 5 9.7 Pointers as Function Parameters CONCEPT: A pointer can be used as a function parameter. It gives the function access to the original argument, much like a reference parameter does. In Chapter 6 you were introduced to the concept of reference variables being used as func- tion parameters. A reference variable acts as an alias to the original vari..."
9.8 Focus on Software Engineering: Dynamic Memory Allocation,553,"Focus on Software Engineering: Dynamic Memory Allocation CONCEPT: Variables may be created and destroyed while a program is running. As long as you know how many variables you will need during the execution of a program, you can define those variables up front. For example, a program to calculate the area of a rectangle will need three variables: one for the rectangle’s length, one for the rectangle’s width, and one to hold the area. If you are writing a program to compute the payroll for 30 employees, you’ll probably create an array of 30 elements to hold the amount of pay for each person. But what about those times when you don’t know how many variables you need? For instance, suppose you want to write a test-averaging program that will average any number of tests. Obviously the program would be very versatile, but how do you store the indi- vidual test scores in memory if you don’t know how many variables to define? Quite sim- ply, you allow the program to create its own variable..."
9.9 Focus on Software Engineering: Returning Pointers from Functions,557,"Focus on Software Engineering: Returning Pointers from Functions CONCEPT: Functions can return pointers, but you must be sure the item the pointer references still exists. Like any other data type, functions may return pointers. For example, the following func- tion locates the null terminator that appears at the end of a string (such as a string literal) and returns a pointer to it. char *findNull(char *str) { char *ptr = str; while (*ptr != '\0') ptr++; return ptr; } The char * return type in the function header indicates the function returns a pointer to a char : char *findNull(char *str) When writing functions that return pointers, you should take care not to create elusive bugs. For instance, see if you can determine what’s wrong with the following function. string *getFullName() { string fullName[3]; cout << ""Enter your first name: ""; getline(cin, fullName[0]); cout << ""Enter your middle name: ""; getline(cin, fullName[1]); cout << ""Enter your last name: ""; getline(cin, fullNam..."
9.10 Using Smart Pointers to Avoid Memory Leaks,564,"9.10 Using Smart Pointers to Avoid Memory Leaks 533 9.10 Using Smart Pointers to Avoid Memory Leaks CONCEPT: C++ 11 introduces smart pointers, objects that work like pointers, but have the ability to automatically delete dynamically allocated memory that is no longer being used. In C++ 11, you can use smart pointers to dynamically allocate memory and not worry about deleting the memory when you are finished using it. A smart pointer automatically deletes a chunk of dynamically allocated memory when the memory is no longer being used. This helps to prevent memory leaks from occurring. C++ 11 provides three types of smart pointer: unique_ptr , shared_ptr , and weak_ptr . To use any of the smart pointers, you must #include the memory header file with the fol- lowing directive: #include <memory> In this book, we introduce unique_ptr . The syntax for defining a unique_ptr is some- what different from the syntax used in defining a regular pointer. Here is an example: unique_ptr<int> ptr( ..."
9.11 Focus on Problem Solving and Program Design: A Case Study,567,"9.11 Focus on Problem Solving and Program Design: A Case Study CONCEPT: This case study demonstrates how an array of pointers can be used to display the contents of a second array in sorted order, without sorting the second array. The United Cause, a charitable relief agency, solicits donations from businesses. The local United Cause office received the following donations from the employees of CK Graphics, Inc.: $5, $100, $5, $25, $10, $5, $25, $5, $5, $100, $10, $15, $10, $5, $10 The donations were received in the order they appear. The United Cause manager has asked you to write a program that displays the donations in ascending order, as well as in their original order. Variables Table 9-1 shows the major variables needed. Programming Strategy In this program the donations array will contain the donations in the order they were received. The elements of the arrPtr array are pointers to integers. They will point to the elements of the donations array, as illustrated in Figure 9-1..."
Review Questions and Exercises,572,"Review Questions and Exercises 541 96 void showArrPtr(int *arr[], int size) 97 { 98 for (int count = 0; count < size; count++) 99 cout << *(arr[count]) << "" ""; 100 cout << endl; 101 } Program Output The donations, sorted in ascending order, are: 5 5 5 5 5 5 10 10 10 10 15 25 25 100 100 The donations, in their original order, are: 5 100 5 25 10 5 25 5 5 100 10 15 10 5 10 Review Questions and Exercises Short Answer 1. What does the indirection operator do? 2. Look at the following code. int x = 7; int *iptr = &x; What will be displayed if you send the expression *iptr to cout ? What happens if you send the expression ptr to cout ? 3. So far you have learned three different uses for the * operator. What are they? 4. What math operations are allowed on pointers? 5. Assuming that ptr is a pointer to an int , what happens when you add 4 to ptr ? 6. Look at the following array definition. int numbers[] = { 2, 4, 6, 8, 10 }; What will the following statement display? cout << *(numbers + 3) ..."
10.1 Character Testing,578,"10.1 Character Testing CONCEPT: The C++ library provides several functions for testing characters. To use these functions you must include the cctype header file. The C++ library provides several functions that allow you to test the value of a character. These functions test a single char argument and return either true or false . * For exam- ple, the following program segment uses the isupper function to determine whether the character passed as an argument is an uppercase letter. If it is, the function returns true . Otherwise, it returns false . char letter = 'a'; if (isupper(letter)) cout << ""Letter is uppercase.\n""; else cout << ""Letter is lowercase.\n""; Because the variable letter , in this example, contains a lowercase character, isupper returns false . The if statement will cause the message “ Letter is lowercase ” to be displayed. Characters, C-Strings, and More About the string Class 10 TOPICS 10.1 Character Testing 10.2 Character Case Conversion 10.3 C-Strings 10.4 Librar..."
10.2 Character Case Conversion,582,"10.2 Character Case Conversion 551 In this program, the customer number is expected to consist of three alphabetic letters fol- lowed by four numeric digits. The testNum function accepts an array argument and tests the first three characters with the following loop in lines 45 through 49: for (count = 0; count < 3; count++) { if (!isalpha(custNum[count])) return false; } The isalpha function returns true if its argument is an alphabetic character. The ! opera- tor is used in the if statement to determine whether the tested character is NOT alpha- betic. If this is so for any of the first three characters, the function testNum returns false . Likewise, the next four characters are tested to determine whether they are numeric digits with the following loop in lines 52 through 56: for (count = 3; count < size - 1; count++) { if (!isdigit(custNum[count])) return false; } The isdigit function returns true if its argument is the character representation of any of the digits 0 through 9. O..."
10.3 C-Strings,585,"10.3 C-Strings CONCEPT: In C++, a C-string is a sequence of characters stored in consecutive mem- ory locations, terminated by a null character. String is a generic term that describes any consecutive sequence of characters. A word, a sentence, a person’s name, and the title of a song are all strings. In the C++ language, there are two primary ways that strings are stored in memory: as string objects, or as C-strings. You have already been introduced to the string class, and by now, you have written sev- eral programs that use string objects. In this section, we will use C-strings, which are an alternative method for storing and working with strings. A C-string is a string whose characters are stored in consecutive memory locations and are followed by a null character, or null terminator. Recall from Chapter 2 that a null character or null terminator is a byte holding the ASCII code 0. Strings that are stored this way are called C-strings because this is the way strings are handled ..."
10.4 Library Functions for Working with C-Strings,589,"10.4 Library Functions for Working with C-Strings CONCEPT: The C++ library has numerous functions for handling C-strings. These functions perform various tests and manipulations and require that the cstring header file be included. The strlen Function Because C-strings are stored in arrays, working with them is quite different than working with string objects. Fortunately, the C++ library provides many functions for manipulat- ing and testing C-strings. These functions all require the cstring header file to be included, as shown here: #include <cstring> For instance, the following code segment uses the strlen function to determine the length of the string stored in the name array: char name[] = ""Thomas Edison""; int length; length = strlen(name); The strlen function accepts a pointer to a C-string as its argument. It returns the length of the string, which is the number of characters up to, but not including, the null terminator. As a result, the variable length will have the number ..."
10.5 C-String/Numeric Conversion Functions,600,"10.5 C-String/Numeric Conversion Functions 569 10.9 Write a statement that will copy the string “Beethoven” to the array composer . 10.10 When complete, the following program skeleton will search for the string “ Windy ” in the array place . If place contains “ Windy ” the program will display the message “ Windy found .” Otherwise it will display “ Windy not found. ” #include <iostream> // include any other necessary header files using namespace std; int main() { char place[] = ""The Windy City""; // Complete the program. It should search the array place // for the string ""Windy"" and display the message ""Windy // found"" if it finds the string. Otherwise, it should // display the message ""Windy not found."" return 0; } 10.5 C-String/Numeric Conversion Functions CONCEPT: The C++ library provides functions for converting a C-string representation of a number to a numeric data type and vice versa. There is a great difference between a number that is stored as a string and one stored as a ..."
10.6 Focus on Software Engineering: Writing Your Own C-String-Handling Functions,606,"10.6 Focus on Software Engineering: Writing Your Own C-String-Handling Functions 575 10.13 Write a statement that will convert the string “ 100000 ” to a long and store the result in the variable num . 10.14 Write a statement that will convert the string “ 7.2389 ” to a double and store the result in the variable num . 10.15 Write a statement that will convert the integer 127 to a string, stored in base-10 notation in the array value . 10.6 Focus on Software Engineering: Writing Your Own C-String-Handling Functions CONCEPT: You can design your own specialized functions for manipulating strings. By being able to pass arrays as arguments, you can write your own functions for processing C-strings. For example, Program 10-12 uses a function to copy a C-string from one array to another. Program 10-12 1 // This program uses a function to copy a C-string into an array. 2 #include <iostream> 3 using namespace std; 4 5 void stringCopy(char [], char []); // Function prototype 6 7 int main() 8..."
10.8 Focus on Problem Solving and Program Design: A Case Study,621,"10.8 Focus on Problem Solving and Program Design: A Case Study As a programmer for the Home Software Company, you are asked to develop a function named dollarFormat that inserts commas and a $ sign at the appropriate locations in a string object containing an unformatted dollar amount. As an argument, the function should accept a reference to a string object. You may assume the string object contains a value such as 1084567.89. The function should modify the string object so it contains a formatted dollar amount, such as $1,084,567.89. The code for the dollarFormat function follows. void dollarFormat(string &currency) { int dp; dp = currency.find('.'); // Find decimal point if (dp > 3) // Insert commas { for (int x = dp - 3; x > 0; x -= 3) currency.insert(x, "",""); } currency.insert(0, ""$""); // Insert dollar sign } The function defines an int variable named dp . This variable is used to hold the position of the unformatted number’s decimal point. This is accomplished with the stateme..."
Review Questions and Exercises,622,"Review Questions and Exercises 591 8 // Function prototype 9 void dollarFormat(string &); 10 11 int main () 12 { 13 string input; 14 15 // Get the dollar amount from the user. 16 cout << ""Enter a dollar amount in the form nnnnn.nn : ""; 17 cin >> input; 18 dollarFormat(input); 19 cout << ""Here is the amount formatted:\n""; 20 cout << input << endl; 21 return 0; 22 } 23 24 //************************************************************ 25 // Definition of the dollarFormat function. This function * 26 // accepts a string reference object, which is assumed * 27 // to hold a number with a decimal point. The function * 28 // formats the number as a dollar amount with commas and * 29 // a $ symbol. * 30 //************************************************************ 31 32 void dollarFormat(string &currency) 33 { 34 int dp; 35 36 dp = currency.find('.'); // Find decimal point 37 if (dp > 3) // Insert commas 38 { 39 for (int x = dp - 3; x > 0; x -= 3) 40 currency.insert(x, "",""); 41 } 42 currenc..."
11.1 Abstract Data Types,630,"11.1 Abstract Data Types CONCEPT: Abstract data types (ADTs) are data types created by the programmer. ADTs have their own range (or domain) of data and their own sets of operations that may be performed on them. The term abstract data type, or ADT, is very important in computer science and is especially significant in object-oriented programming. This chapter introduces you to the structure, which is one of C++’s mechanisms for creating abstract data types. Abstraction An abstraction is a general model of something. It is a definition that includes only the gen- eral characteristics of an object. For example, the term “dog” is an abstraction. It defines a general type of animal. The term captures the essence of what all dogs are without specify- ing the detailed characteristics of any particular type of dog. According to Webster’s New Collegiate Dictionary , a dog is a highly variable carnivorous domesticated mammal ( Canis familiaris ) probably descended from the common wolf. In r..."
11.2 Focus on Software Engineering: Combining Data into Structures,632,"11.2 Focus on Software Engineering: Combining Data into Structures 601 For example, suppose a program is created to simulate a 12-hour clock. The program could contain three ADTs: Hours , Minutes , and Seconds . The range of values for the Hours data type would be the integers 1 through 12. The range of values for the Minutes and Seconds data types would be 0 through 59. If an Hours object is set to 12 and then incremented, it will then take on the value 1. Likewise if a Minutes object or a Seconds object is set to 59 and then incremented, it will take on the value 0. Abstract data types often combine several values. In the clock program, the Hours , Minutes , and Seconds objects could be combined to form a single Clock object. In this chapter you will learn how to combine variables of primitive data types to form your own data struc- tures, or ADTs. 11.2 Focus on Software Engineering: Combining Data into Structures CONCEPT: C++ allows you to group several variables together into a ..."
11.3 Accessing Structure Members,635,"11.3 Accessing Structure Members CONCEPT: The dot operator (.) allows you to access structure members in a program. C++ provides the dot operator (a period) to access the individual members of a structure. Using our example of deptHead as a PayRoll structure variable, the following statement demonstrates how to access the empNumber member: deptHead.empNumber = 475; In this statement, the number 475 is assigned to the empNumber member of deptHead . The dot operator connects the name of the member variable with the name of the structure variable it belongs to. The following statements assign values to the empNumber members of the deptHead , foreman , and associate structure variables: deptHead.empNumber = 475; foreman.empNumber = 897; associate.empNumber = 729; With the dot operator you can use member variables just like regular variables. For example these statements display the contents of deptHead ’s members: cout << deptHead.empNumber << endl; cout << deptHead.name << endl; cout <..."
11.4 Initializing a Structure,639,"11.4 Initializing a Structure CONCEPT: The members of a structure variable may be initialized with starting values when the structure variable is defined. A structure variable may be initialized when it is defined, in a fashion similar to the initializa- tion of an array. Assume the following structure declaration exists in a program: struct CityInfo { string cityName; string state; long population; int distance; }; A variable may then be defined with an initialization list, as shown in the following: CityInfo location = {""Asheville"", ""NC"", 50000, 28}; This statement defines the variable location . The first value in the initialization list is assigned to the first declared member, the second value in the initialization list is assigned to the second member, and so on. The location variable is initialized in the following manner: The string “Asheville” is assigned to location.cityName The string “NC” is assigned to location.state 50000 is assigned to location.population 28 is assign..."
11.5 Arrays of Structures,642,"11.5 Arrays of Structures 611 cout << ""Producer: ""; // Write a statement here that lets the user enter the // name of the movie's producer. Store the name in the // structure variable. cout << ""Year of release: ""; // Write a statement here that lets the user enter the // year the movie was released. Store the year in the // structure variable. cout << ""Here is data on your favorite movie:\n""; // Write statements here that display the data. // just entered into the structure variable. return 0; } 11.5 Arrays of Structures CONCEPT: Arrays of structures can simplify some programming tasks. In Chapter 7 you saw that data can be stored in two or more arrays, with a relationship established between the arrays through their subscripts. Because structures can hold several items of varying data types, a single array of structures can be used in place of several arrays of regular variables. An array of structures is defined like any other array. Assume the following structure dec- laration ex..."
11.6 Focus on Software Engineering: Nested Structures,644,"11.6 Focus on Software Engineering: Nested Structures 613 Program Output with Example Input Shown in Bold Enter the hours worked by 3 employees and their hourly rates. Hours worked by employee #1: 10 [Enter] Hourly pay rate for employee #1: 9.75 [Enter] Hours worked by employee #2: 20 [Enter] Hourly pay rate for employee #2: 10.00 [Enter] Hours worked by employee #3: 40 [Enter] Hourly pay rate for employee #3: 20.00 [Enter] Here is the gross pay for each employee: Employee #1: $97.50 Employee #2: $200.00 Employee #3: $800.00 Initializing a Structure Array To initialize a structure array, simply provide an initialization list for one or more of the elements. For example, the array in Program 11-4 could have been initialized as follows: PayInfo workers[NUM_WORKERS] = { {10, 9.75 }, {15, 8.62 }, {20, 10.50}, {40, 18.75}, {40, 15.65} }; As in all single-dimensional arrays, you can initialize all or part of the elements in an array of structures, as long as you do not skip elements. 11.6..."
11.7 Structures as Function Arguments,648,"11.7 Structures as Function Arguments 617 11.7 Structures as Function Arguments CONCEPT: Structure variables may be passed as arguments to functions. Like other variables, the individual members of a structure variable may be used as function arguments. For example, assume the following structure declaration exists in a program: struct Rectangle { double length; double width; double area; }; Let’s say the following function definition exists in the same program: double multiply(double x, double y) { return x * y; } Assuming that box is a variable of the Rectangle structure type, the following function call will pass box.length into x and box.width into y . The return value will be stored in box.area . box.area = multiply(box.length, box.width); Sometimes it’s more convenient to pass an entire structure variable into a function instead of individual members. For example, the following function definition uses a Rectangle structure variable as its parameter: void showRect(Rectangle r)..."
11.8 Returning a Structure from a Function,651,"11.8 Returning a Structure from a Function CONCEPT: A function may return a structure. Just as functions can be written to return an int , long , double , or other data type, they can also be designed to return a structure. Recall the following structure declaration from Program 11-2 : struct Circle { double radius; double diameter; double area; }; A function, such as the following, could be written to return a variable of the Circle data type: Circle getCircleData() { Circle temp; // Temporary Circle structure temp.radius = 10.0; // Store the radius temp.diameter = 20.0; // Store the diameter 11.8 Returning a Structure from a Function 621 temp.area = 314.159; // Store the area return temp; // Return the temporary structure } Notice that the getCircleData function has a return data type of Circle . That means the function returns an entire Circle structure when it terminates. The return value can be assigned to any variable that is a Circle structure. The following statement, for ex..."
11.9 Pointers to Structures,654,"11.9 Pointers to Structures 623 11.9 Pointers to Structures CONCEPT: You may take the address of a structure variable and create variables that are pointers to structures. Defining a variable that is a pointer to a structure is as simple as defining any other pointer variable: The data type is followed by an asterisk and the name of the pointer variable. Here is an example: Circle *cirPtr = nullptr; This statement defines cirPtr as a pointer to a Circle structure. Look at the following code: Circle myCircle = { 10.0, 20.0, 314.159 }; Circle *cirPtr = nullptr; cirPtr = &myCircle; The first two lines define myCircle , a structure variable, and cirPtr , a pointer. The third line assigns the address of myCircle to cirPtr . After this line executes, cirPtr will point to the myCircle structure. This is illustrated in Figure 11-4 . cirPtr 0xA604 myCircle Structure At Address 0xA604 Figure 11-4 Indirectly accessing the members of a structure through a pointer can be clumsy, however, if the ..."
"11.10 Focus on Software Engineering: When to Use . , When to Use -> , and When to Use *",657,"11.10 Focus on Software Engineering: When to Use . , When to Use -> , and When to Use * Sometimes structures contain pointers as members. For example, the following structure declaration has an int pointer member: struct GradeInfo { string name; // Student names int *testScores; // Dynamically allocated array float average; // Test average }; It is important to remember that the structure pointer operator ( -> ) is used to dereference a pointer to a structure, not a pointer that is a member of a structure. If a program derefer- ences the testScores pointer in this structure, the indirection operator must be used. For example, assume that the following variable has been defined: GradeInfo student1; The following statement will display the value pointed to by the testScores member: cout << *student1.testScores; It is still possible to define a pointer to a structure that contains a pointer member. For instance, the following statement defines stPtr as a pointer to a GradeInfo structur..."
11.11 Unions,659,"Unions CONCEPT: A union is like a structure, except all the members occupy the same memory area. A union, in almost all regards, is just like a structure. The difference is that all the members of a union use the same memory area, so only one member can be used at a time. A union might be used in an application where the program needs to work with two or more values (of different data types), but only needs to use one of the values at a time. Unions conserve memory by storing all their members in the same memory location. Unions are declared just like structures, except the key word union is used instead of struct . Here is an example: union PaySource { short hours; float sales; }; A union variable of the data type shown above can then be defined as PaySource employee1; The PaySource union variable defined here has two members: hours (a short ), and sales (a float ). The entire variable will only take up as much memory as the largest member (in this case, a float ). The way this var..."
11.12 Enumerated Data Types,663,"11.12 Enumerated Data Types CONCEPT: An enumerated data type is a programmer-defined data type. It consists of values known as enumerators, which represent integer constants. Using the enum key word you can create your own data type and specify the values that belong to that type. Such a type is known as an enumerated data type . Here is an example of an enumerated data type declaration: enum Day { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY }; An enumerated type declaration begins with the key word enum , followed by the name of the type, followed by a list of identifiers inside braces, and is terminated with a semico- lon. The example declaration creates an enumerated data type named Day . The identifiers MONDAY , TUESDAY , WEDNESDAY , THURSDAY , and FRIDAY , which are listed inside the braces, Program 11-10 (continued) Program Output with Example Input Shown in Bold This program calculates either hourly wages or sales commission. Enter H for hourly wages or C for commission: C [..."
Review Questions and Exercises,675,"Review Questions and Exercises Short Answer 1. What is a primitive data type? 2. Does a structure declaration cause a structure variable to be created? 3. Both arrays and structures are capable of storing multiple values. What is the difference between an array and a structure? 4. Look at the following structure declaration. struct Point { int x; int y; }; Write statements that A) define a Point structure variable named center B) assign 12 to the x member of center C) assign 7 to the y member of center D) display the contents of the x and y members of center 5. Look at the following structure declaration. struct FullName { string lastName; string middleName; string firstName; }; Write statements that A) Define a FullName structure variable named info B) Assign your last, middle, and first name to the members of the info variable C) Display the contents of the members of the info variable 6. Look at the following code. struct PartData { string partName; int idNumber; }; PartData inve..."
CHAPTER 12 Advanced File Operations,688,"12.1 File Operations CONCEPT: A file is a collection of data that is usually stored on a computer’s disk. Data can be saved to files and then later reused. Almost all real-world programs use files to store and retrieve data. Here are a few examples of familiar software packages that use files extensively. • Word Processors: Word processing programs are used to write letters, memos, reports, and other documents. The documents are then saved in files so they can be edited and reprinted. • Database Management Systems: DBMSs are used to create and maintain databases. Databases are files that contain large collections of data, such as payroll records, inventories, sales statistics, and customer records. • Spreadsheets: Spreadsheet programs are used to work with numerical data. Numbers and mathematical formulas can be inserted into the rows and columns of the spread- sheet. The spreadsheet can then be saved to a file for use later. • Compilers: Compilers translate the source code of a pro..."
12.1 File Operations,688,"12.1 File Operations CONCEPT: A file is a collection of data that is usually stored on a computer’s disk. Data can be saved to files and then later reused. Almost all real-world programs use files to store and retrieve data. Here are a few examples of familiar software packages that use files extensively. • Word Processors: Word processing programs are used to write letters, memos, reports, and other documents. The documents are then saved in files so they can be edited and reprinted. • Database Management Systems: DBMSs are used to create and maintain databases. Databases are files that contain large collections of data, such as payroll records, inventories, sales statistics, and customer records. • Spreadsheets: Spreadsheet programs are used to work with numerical data. Numbers and mathematical formulas can be inserted into the rows and columns of the spread- sheet. The spreadsheet can then be saved to a file for use later. • Compilers: Compilers translate the source code of a pro..."
12.2 File Output Formatting,694,"12.2 File Output Formatting 663 You may also test for errors after you have opened a file with this technique. The following code shows an example. ifstream inputFile(""SalesData.txt""); if (!inputFile) cout << ""Error opening SalesData.txt.\n""; Checkpoint 12.1 Which file access flag would you use if you want all output to be written to the end of an existing file? 12.2 How do you use more than one file access flag? 12.3 Assuming that diskInfo is an fstream object, write a statement that opens the file names.dat for output. 12.4 Assuming that diskInfo is an fstream object, write a statement that opens the file customers.txt for output, where all output will be written to the end of the file. 12.5 Assuming that diskInfo is an fstream object, write a statement that opens the file payable.txt for both input and output. 12.6 Write a statement that defines an fstream object named dataFile and opens a file named salesfigures.txt for input. ( Note: The file should be opened with the definitio..."
12.3 Passing File Stream Objects to Functions,696,"12.3 Passing File Stream Objects to Functions 665 16 // Write the three rows of numbers with each 17 // number in a field of 8 character spaces. 18 for (int row = 0; row < ROWS; row++) 19 { 20 for (int col = 0; col < COLS; col++) 21 { 22 outFile << setw(8) << nums[row][col]; 23 } 24 outFile << endl; 25 } 26 outFile.close(); 27 cout << ""Done.\n""; 28 return 0; 29 } Contents of File table.txt 2897 5 837 34 7 1623 390 3456 12 Figure 12-4 shows the way the characters appear in the file. 2 8 9 7 5 8 3 7 \n 3 4 7 \n 1 6 2 3 3 9 0 1 2 \n 3 4 5 6 <EOF> Figure 12-4 12.3 Passing File Stream Objects to Functions CONCEPT: File stream objects may be passed by reference to functions. When writing actual programs, you’ll want to create modularized code for handling file operations. File stream objects may be passed to functions, but they should always be passed by reference. The openFile function shown below uses an fstream reference object parameter: bool openFileIn(fstream &file, string name) { b..."
12.4 More Detailed Error Testing,698,"12.4 More Detailed Error Testing 667 37 bool openFileIn(fstream &file, string name) 38 { 39 file.open(name, ios::in); 40 if (file.fail()) 41 return false; 42 else 43 return true; 44 } 45 46 //************************************************************ 47 // Definition of function showContents. Accepts an fstream * 48 // reference as its argument. Uses a loop to read each name * 49 // from the file and displays it on the screen. * 50 //************************************************************ 51 52 void showContents(fstream &file) 53 { 54 string line; 55 56 while (file >> line) 57 { 58 cout << line << endl; 59 } 60 } Program Output File opened successfully. Now reading data from the file. Jones Smith Willis Davis Done. 12.4 More Detailed Error Testing CONCEPT: All stream objects have error state bits that indicate the condition of the stream. All stream objects contain a set of bits that act as flags. These flags indicate the current state of the stream. Table 12-4 lists these bi..."
12.5 Member Functions for Reading and Writing Files,701,"12.5 Member Functions for Reading and Writing Files CONCEPT: File stream objects have member functions for more specialized file reading and writing. If whitespace characters are part of the data in a file, a problem arises when the file is read by the >> operator. Because the operator considers whitespace characters as delimiters, it Program 12-6 (continued) 12.5 Member Functions for Reading and Writing Files 671 does not read them. For example, consider the file murphy.txt , which contains the fol- lowing data: Jayne Murphy 47 Jones Circle Almond, NC 28702 Figure 12-5 shows the way the data is recorded in the file. J a y n e u r p h y \n 4 7 M J o n e s C i r c l e \n A l m o n d , N C 2 8 7 0 2 \n <EOF> Figure 12-5 The problem that arises from the use of the >> operator is evident in the output of Program 12-7 . Program 12-7 1 // This program demonstrates how the >> operator should not 2 // be used to read data that contain whitespace characters 3 // from a file. 4 #include <iost..."
12.6 Focus on Software Engineering: Working with Multiple Files,709,"12.6 Focus on Software Engineering: Working with Multiple Files CONCEPT: It’s possible to have more than one file open at once in a program. Quite often you will need to have multiple files open at once. In many real-world applications, data about a single item are categorized and written to several different files. For example, a payroll system might keep the following files: emp.dat A file that contains the following data about each employee: name, job title, address, telephone number, employee number, and the date hired. pay.dat A file that contains the following data about each employee: employee number, hourly pay rate, overtime rate, and number of hours worked in the current pay cycle. withhold.dat A file that contains the following data about each employee: employee number, dependents, and extra withholdings. When the system is writing paychecks, you can see that it will need to open each of the files listed above and read data from them. (Notice that each file contains the e..."
12.7 Binary Files,711,"12.7 Binary Files CONCEPT: Binary files contain data that is not necessarily stored as ASCII text. All the files you’ve been working with so far have been text files. That means the data stored in the files has been formatted as ASCII text. Even a number, when stored in a file with the << operator, is converted to text. For example, consider the following program segment: ofstream file(""num.dat""); short x = 1297; file << x; The last statement writes the contents of x to the file. When the number is written, however, it is stored as the characters '1' , '2' , '9' , and '7' . This is illustrated in Figure 12-6 . Program 12-12 (continued) '1' 1297 expressed in ASCII '2' '9' '7' <EOF> 49 50 57 55 <EOF> Figure 12-6 00000101 1297 as a short integer, in binary 1297 as a short integer, in hexadecimal 00010001 05 11 Figure 12-7 The number 1297 isn’t stored in memory (in the variable x ) in the fashion depicted in the fig- ure above, however. It is formatted as a binary number, occupying two ..."
12.8 Creating Records with Structures,716,"12.8 Creating Records with Structures 685 Program Output Writing the data to the file. Now reading the data back into memory. 1 2 3 4 5 6 7 8 9 10 12.8 Creating Records with Structures CONCEPT: Structures may be used to store fixed-length records to a file. Earlier in this chapter the concept of fields and records was introduced. A field is an indi- vidual piece of data pertaining to a single item. A record is made up of fields and is a complete set of data about a single item. For example, a set of fields might be a person’s name, age, address, and phone number. Together, all those fields that pertain to one person make up a record. In C++, structures provide a convenient way to organize data into fields and records. For example, the following code could be used to create a record containing data about a person. const int NAME_SIZE = 51, ADDR_SIZE = 51, PHONE_SIZE = 14; struct Info { char name[NAME_SIZE]; int age; char address1[ADDR_SIZE]; char address2[ADDR_SIZE]; char phone[PHONE..."
12.9 Random-Access Files,720,"12.9 Random-Access Files 689 Press the Enter key to see the next record. Name: Merideth Murney Age: 22 Address line 1: 487 Lindsay Lane Address line 2: Hazelwood, NC 28737 Phone: (828)555-9999 Press the Enter key to see the next record. That's all the data in the file! NOTE: Structures containing pointers cannot be correctly stored to disk using the techniques of this section. This is because if the structure is read into memory on a sub- sequent run of the program, it cannot be guaranteed that all program variables will be at the same memory locations. Because string class objects contain implicit pointers, they cannot be a part of a structure that has to be stored. 12.9 Random-Access Files CONCEPT: Random access means nonsequentially accessing data in a file. All of the programs created so far in this chapter have performed sequential file access . When a file is opened, the position where reading and/or writing will occur is at the file’s beginning (unless the ios::app mode is us..."
12.10 Opening a File for Both Input and Output,728,"12.10 Opening a File for Both Input and Output 697 dataFile.clear(); // Clear the eof flag. dataFile.seekg(0L, ios::beg); // Rewind the read position. // // Read and process the file's contents again. // dataFile.close(); // Close the file. Notice that prior to calling the seekg member function, the clear member function is called. As previously mentioned this clears the file object’s eof flag and is necessary only if the program has read to the end of the file. This approach eliminates the need to close and reopen the file each time the file’s contents are processed. 12.10 Opening a File for Both Input and Output CONCEPT: You may perform input and output on an fstream file without closing it and reopening it. Sometimes you’ll need to perform both input and output on a file without closing and reopening it. For example, consider a program that allows you to search for a record in a file and then make changes to it. A read operation is necessary to copy the data from the file to memo..."
Review Questions and Exercises,733,"Review Questions and Exercises Short Answer 1. What capability does the fstream data type provide that the ifstream and ofstream data types do not? 2. Which file access flag do you use to open a file when you want all output written to the end of the file’s existing contents? 3. Assume that the file data.txt already exists, and the following statement executes. What happens to the file? fstream file(""data.txt"", ios::out); 4. How do you combine multiple file access flags when opening a file? 5. Should file stream objects be passed to functions by value or by reference? Why? 6. Under what circumstances is a file stream object’s ios::hardfail bit set? What mem- ber function reports the state of this bit? 7. Under what circumstances is a file stream object’s ios::eofbit bit set? What member function reports the state of this bit? 8. Under what circumstances is a file stream object’s ios::badbit bit set? What member function reports the state of this bit? 9. How do you read the contents ..."
13.1 Procedural and Object-Oriented Programming,742,"13.1 Procedural and Object-Oriented Programming CONCEPT: Procedural programming is a method of writing software. It is a pro- gramming practice centered on the procedures or actions that take place in a program. Object-oriented programming is centered around the object. Objects are created from abstract data types that encapsulate data and functions together. There are two common programming methods in practice today: procedural programming and object-oriented programming (or OOP). Up to this chapter, you have learned to write procedural programs. Introduction to Classes 13 TOPICS 13.1 Procedural and Object-Oriented Programming 13.2 Introduction to Classes 13.3 Defining an Instance of a Class 13.4 Why Have Private Members? 13.5 Focus on Software Engineering: Separating Class Specification from Implementation 13.6 Inline Member Functions 13.7 Constructors 13.8 Passing Arguments to Constructors 13.9 Destructors 13.10 Overloading Constructors 13.11 Private Member Functions 13.12 Arrays..."
13.2 Introduction to Classes,749,"Chapter 13 Introduction to Classes 13.2 Introduction to Classes CONCEPT: In C++, the class is the construct primarily used to create objects. A class is similar to a structure. It is a data type defined by the programmer, consisting of variables and functions. Here is the general format of a class declaration: class ClassName { declaration ; // ... more declarations // may follow... }; The declaration statements inside a class declaration are for the variables and functions that are members of that class. For example, the following code declares a class named Rectangle with two member variables: width and length . class Rectangle { double width; double length; }; // Don't forget the semicolon. There is a problem with this class, however. Unlike structures, the members of a class are private by default. Private class members cannot be accessed by programming statements outside the class. So, no statements outside this Rectangle class can access the width and length members. Recall fr..."
13.3 Defining an Instance of a Class,754,"13.3 Defining an Instance of a Class 723 Using const with Accessors Notice that the key word const appears in the headers of the getWidth , getLength , and getArea member functions, as shown here: double Rectangle::getWidth() const double Rectangle::getLength() const double Rectangle::getArea() const Recall that these functions were also declared in the class with the const key word. When you mark a member function as const , the const key word must appear in both the dec- laration and the function header. In essence, when you mark a member function as const , you are telling the compiler that the calling object is a constant. The compiler will generate an error if you inadvertently write code in the function that changes the calling object’s data. Because this decreases the chances of having bugs in your code, it is a good practice to mark all accessor functions as const . The Importance of Data Hiding As a beginning student, you might be wondering why you would want to hide the da..."
13.4 Why Have Private Members?,767,"13.4 Why Have Private Members? CONCEPT: In object-oriented programming, an object should protect its important data by making it private and providing a public interface to access that data. You might be questioning the rationale behind making the member variables in the Rectangle class private. You might also be questioning why member functions were defined for such simple tasks as setting variables and getting their contents. After all, if the member variables were declared as public , the member functions wouldn’t be needed. As mentioned earlier in this chapter, classes usually have variables and functions that are meant only to be used internally. They are not intended to be accessed by statements out- side the class. This protects critical data from being accidentally modified or used in a way that might adversely affect the state of the object. When a member variable is declared as private , the only way for an application to store values in the variable is through a public me..."
13.5 Focus on Software Engineering: Separating Class Specification from Implementation,768,"13.5 Focus on Software Engineering: Separating Class Specification from Implementation 737 else { cout << ""Invalid width\n""; exit(EXIT_FAILURE); } } Notice that this version of the function doesn’t just assign the parameter value to the width variable. It first tests the parameter to make sure it is 0 or greater. If a negative number was passed to the function, an error message is displayed, and then the standard library function exit is called to abort the program. The setLength function could be written in a similar way: void Rectangle::setLength(double len) { if (len >= 0) length = len; else { cout << ""Invalid length\n""; exit(EXIT_FAILURE); } } The point being made here is that mutator functions can do much more than simply store values in attributes. They can also validate those values to ensure that only acceptable data is stored in the object’s attributes. Keep in mind, however, that calling the exit function, as we have done in these examples, is not the best way to deal with..."
13.6 Inline Member Functions,774,"13.6 Inline Member Functions 743 Separating a class into specification and implementation files also makes things easier when the class’s member functions must be modified. It is only necessary to modify the imple- mentation file and recompile it to a new object file. Programs that use the class don’t have to be completely recompiled, just linked with the new object file. 13.6 Inline Member Functions CONCEPT: When the body of a member function is written inside a class declaration, it is declared inline. When the body of a member function is small, it is usually more convenient to place the function’s definition, instead of its prototype, in the class declaration. For example, in the Rectangle class the member functions getWidth , getLength , and getArea each have only one statement. The Rectangle class could be revised as shown in the following listing. (This file is stored in the Student Source Code Folder Chapter 13 \Rectangle Version 2 .) Contents of Rectangle.h (Version 2) 1 //..."
13.7 Constructors,777,"13.7 Constructors CONCEPT: A constructor is a member function that is automatically called when a class object is created. A constructor is a member function that has the same name as the class. It is automatically called when the object is created in memory, or instantiated. It is helpful to think of con- structors as initialization routines. They are very useful for initializing member variables or performing other setup operations. To illustrate how constructors work, look at this Demo class declaration: class Demo { public: Demo(); // Constructor }; Demo::Demo() { cout << ""Welcome to the constructor!\n""; } The class Demo only has one member: a function also named Demo . This function is the constructor. When an instance of this class is defined, the function Demo is automatically called. This is illustrated in Program 13-6 . Program 13-6 1 // This program demonstrates a constructor. 2 #include <iostream> 3 using namespace std; 4 5 // Demo class declaration. 6 7 class Demo 8 { 9 ..."
13.8 Passing Arguments to Constructors,781,"13.8 Passing Arguments to Constructors CONCEPT: A constructor can have parameters and can accept arguments when an object is created. Constructors may accept arguments in the same way as other functions. When a class has a constructor that accepts arguments, you can pass initialization values to the constructor when you create an object. For example, the following code shows yet another version of the Rectangle class. This version has a constructor that accepts arguments for the rect- angle’s width and length. (These files are stored in the Student Source Code Folder Chapter 13 \Rectangle Version 4 .) 13.8 Passing Arguments to Constructors 751 Contents of Rectangle.h (Version 4) 1 // Specification file for the Rectangle class 2 // This version has a constructor. 3 #ifndef RECTANGLE_H 4 #define RECTANGLE_H 5 6 class Rectangle 7 { 8 private: 9 double width; 10 double length; 11 public: 12 Rectangle(double, double); // Constructor 13 void setWidth(double); 14 void setLength(double); 15..."
13.9 Destructors,789,"13.9 Destructors CONCEPT: A destructor is a member function that is automatically called when an object is destroyed. Destructors are member functions with the same name as the class, preceded by a tilde char- acter (~). For example, the destructor for the Rectangle class would be named ~Rectangle . Destructors are automatically called when an object is destroyed. In the same way that con- structors set things up when an object is created, destructors perform shutdown procedures when the object goes out of existence. For example, a common use of destructors is to free memory that was dynamically allocated by the class object. Program 13-11 shows a simple class with a constructor and a destructor. It illustrates when, during the program’s execution, each is called. Program 13-11 1 // This program demonstrates a destructor. 2 #include <iostream> 3 using namespace std; 4 5 class Demo 6 { 7 public: 8 Demo(); // Constructor 9 ~Demo(); // Destructor 10 }; 11 12 Demo::Demo() 13 { 14 cout <..."
13.10 Overloading Constructors,793,"13.10 Overloading Constructors CONCEPT: A class can have more than one constructor. Recall from Chapter 6 that when two or more functions share the same name, the func- tion is said to be overloaded. Multiple functions with the same name may exist in a C++ program, as long as their parameter lists are different. A class’s member functions may be overloaded, including the constructor. One constructor might take an integer argument, for example, while another constructor takes a double . There could even be a third constructor taking two integers. As long as each construc- tor takes a different list of parameters, the compiler can tell them apart. For example, the string class has several overloaded constructors. The following statement creates a string object with no arguments passed to the constructor: string str; This executes the string class’s default constructor, which stores an empty string in the object. Another way to create a string object is to pass a string literal as an a..."
13.11 Private Member Functions,796,"13.11 Private Member Functions 765 Description: Wrench Cost: $8.75 Units on Hand: 20 Only One Default Constructor and One Destructor When an object is defined without an argument list for its constructor, the compiler auto- matically calls the default constructor. For this reason, a class may have only one default constructor. If there were more than one constructor that could be called without an argu- ment, the compiler would not know which one to call by default. Remember, a constructor whose parameters all have a default argument is considered a default constructor. It would be an error to create a constructor that accepts no parameters along with another constructor that has default arguments for all its parameters. In such a case the compiler would not be able to resolve which constructor to execute. Classes may also only have one destructor. Because destructors take no arguments, the compiler has no way to distinguish different destructors. Other Overloaded Member Functions M..."
13.12 Arrays of Objects,798,"13.12 Arrays of Objects 767 initPhone function allocates memory for the phone attribute and initializes it with the value pointed to by the p parameter. These functions are private because they should be called only from the constructor. If they were ever called by code outside the class, they would change the values of the name and phone pointers without deallocating the memory that they currently point to. 13.12 Arrays of Objects CONCEPT: You may define and work with arrays of class objects. As with any other data type in C++, you can define arrays of class objects. An array of InventoryItem objects could be created to represent a business’s inventory records. Here is an example of such a definition: const int ARRAY_SIZE = 40; InventoryItem inventory[ARRAY_SIZE]; This statement defines an array of 40 InventoryItem objects. The name of the array is inventory , and the default constructor is called for each object in the array. If you wish to define an array of objects and call a co..."
13.13 Focus on Problem Solving and Program Design: An OOP Case Study,802,13.13 Focus on Problem Solving and Program Design: An OOP Case Study 771 13.13 Focus on Problem Solving and Program Design: An OOP Case Study You are a programmer for the Home Software Company. You have been assigned to develop a class that models the basic workings of a bank account. The class should perform the following tasks: • Save the account balance. • Save the number of transactions performed on the account. • Allow deposits to be made to the account. • Allow withdrawals to be taken from the account. • Calculate interest for the period. • Report the current account balance at any time. • Report the current number of transactions at any time. Private Member Variables Table 13-4 lists the private member variables needed by the class. Table 13-4 Variable Description balance A double that holds the current account balance. interestRate A double that holds the interest rate for the period. interest A double that holds the interest earned for the current period. transactions An in...
13.14 Focus on Object-Oriented Programming: Simulating Dice with Objects,809,"13.14 Focus on Object-Oriented Programming: Simulating Dice with Objects Dice traditionally have six sides, representing the values 1 to 6. Some games, however, use specialized dice that have a different number of sides. For example, the fantasy role-playing game Dungeons and Dragons ® uses dice with four, six, eight, ten, twelve, and twenty sides. Suppose you are writing a program that needs to roll simulated dice with various numbers of sides. A simple approach would be to write a Die class with a constructor that accepts the number of sides as an argument. The class would also have appropriate methods for rolling the die and getting the die’s value. An example of such a class follows. (These files are stored in the Student Source Code Folder Chapter 13 \Dice .) Contents of Die.h 1 // Specification file for the Die class 2 #ifndef DIE_H 3 #define DIE_H 4 5 class Die 6 { 7 private: 8 int sides; // Number of sides 9 int value; // The die's value 10 11 public: 12 Die(int = 6); // Con..."
13.15 Focus on Object-Oriented Programming: Creating an Abstract Array Data Type,813,"13.15 Focus on Object-Oriented Programming: Creating an Abstract Array Data Type CONCEPT: The absence of array bounds checking in C++ is a source of potential hazard. In this section we examine a simple integer list class that provides bounds checking. One of the benefits of object-oriented programming is the ability to create abstract data types that are improvements on built-in data types. As you know, arrays provide no bounds checking in C++. You can, however, create a class that has array-like characteristics and performs bounds checking. For example, look at the following IntegerList class. Contents of IntegerList.h 1 // Specification file for the IntegerList class. 2 #ifndef INTEGERLIST_H 3 #define INTEGERLIST_H 4 5 class IntegerList 6 { 7 private: 8 int *list; // Pointer to the array. 9 int numElements; // Number of elements. 10 bool isValid(int); // Validates subscripts. 11 public: 12 IntegerList(int); // Constructor 13 ~IntegerList(); // Destructor 14 void setElement(int, i..."
13.16 Focus on Object-Oriented Design: The Unified Modeling Language (UML),816,"13.16 Focus on Object-Oriented Design: The Unified Modeling Language (UML) 785 7 { 8 const int SIZE = 20; 9 IntegerList numbers(SIZE); 10 int val, x; 11 12 // Store 9s in the list and display an asterisk 13 // each time a 9 is successfully stored. 14 for (x = 0; x < SIZE; x++) 15 { 16 numbers.setElement(x, 9); 17 cout << ""* ""; 18 } 19 cout << endl; 20 21 // Display the 9s. 22 for (x = 0; x < SIZE; x++) 23 { 24 val = numbers.getElement(x); 25 cout << val << "" ""; 26 } 27 cout << endl; 28 29 // Attempt to store a value outside the list's bounds. 30 numbers.setElement(50, 9); 31 32 // Will this message display? 33 cout << ""Element 50 successfully set.\n""; 34 return 0; 35 } Program Output * * * * * * * * * * * * * * * * * * * * 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 Error: Invalid subscript 13.16 Focus on Object-Oriented Design: The Unified Modeling Language (UML) CONCEPT: The Unified Modeling Language provides a standard method for graphically depicting an object-oriented system. When ..."
13.17 Focus on Object-Oriented Design: Finding the Classes and Their Responsibilities,819,"13.17 Focus on Object-Oriented Design: Finding the Classes and Their Responsibilities CONCEPT: One of the first steps in creating an object-oriented application is determining the classes that are necessary and their responsibilities within the application. So far you have learned the basics of writing a class, creating an object from the class, and using the object to perform operations. This knowledge is necessary to create an object-oriented application, but it is not the first step in designing the application. The first step is to analyze the problem that you are trying to solve and determine the classes that you will need. In this section we will discuss a simple technique for finding the classes in a problem and determining their responsibilities. Finding the Classes When developing an object-oriented application, one of your first tasks is to identify the classes that you will need to create. Typically, your goal is to identify the different types of real-world objects that ..."
Review Questions and Exercises,828,"Review Questions and Exercises 797 shows the patient’s name and address, as well as the procedures that were per- formed, and the total charge for the procedures. Assume that you are writing an application to generate a statement that can be printed and given to the patient. A) Identify all of the potential classes in this problem domain. B) Refine the list to include only the necessary class or classes for this problem. C) Identify the responsibilities of the class or classes that you identified in step B. Review Questions and Exercises Short Answer 1. What is the difference between a class and an instance of the class? 2. What is the difference between the following Person structure and Person class? struct Person { string name; int age; }; class Person { string name; int age; }; 3. What is the default access specification of class members? 4. Look at the following function header for a member function. void Circle::getRadius() What is the name of the function? What class is the f..."
14.1 Instance and Static Members,842,"14.1 Instance and Static Members CONCEPT: Each instance of a class has its own copies of the class’s instance variables. If a member variable is declared static , however, all instances of that class have access to that variable. If a member function is declared static , it may be called without any instances of the class being defined. Instance Variables Each class object (an instance of a class) has its own copy of the class’s member variables. An object’s member variables are separate and distinct from the member variables of other objects of the same class. For example, recall that the Rectangle class discussed in Chapter 13 has two member variables: width and length . Suppose that we define two objects of the Rectangle class and set their width and length member variables as shown in the following code. Rectangle box1, box2; // Set the width and length for box1. box1.setWidth(5); box1.setLength(10); // Set the width and length for box2. box2.setWidth(500); box2.setLength(1000);..."
14.2 Friends of Classes,850,"14.2 Friends of Classes 819 14.2 Friends of Classes CONCEPT: A friend is a function or class that is not a member of a class, but has access to the private members of the class. Private members are hidden from all parts of the program outside the class, and accessing them requires a call to a public member function. Sometimes you will want to create an exception to that rule. A friend function is a function that is not part of a class, but that has access to the class’s private members. In other words, a friend function is treated as if it were a member of the class. A friend function can be a regular stand-alone function, or it can be a member of another class. (In fact, an entire class can be declared a friend of another class.) In order for a function or class to become a friend of another class, it must be declared as such by the class granting it access. Classes keep a “list” of their friends, and only the external functions or classes whose names appear in the list are granted..."
14.3 Memberwise Assignment,855,"14.3 Memberwise Assignment CONCEPT: The = operator may be used to assign one object's data to another object, or to initialize one object with another object's data. By default, each member of one object is copied to its counterpart in the other object. Like other variables (except arrays), objects may be assigned to one another using the = operator. As an example, consider Program 14-5, which uses the Rectangle class (version 4) that we discussed in Chapter 13 . Recall that the Rectangle class has two member vari- ables: width and length . The constructor accepts two arguments, one for width and one for length . Program 14-5 1 // This program demonstrates memberwise assignment. 2 #include <iostream> 3 #include ""Rectangle.h"" 4 using namespace std; 5 6 int main() 7 { 8 // Define two Rectangle objects. 9 Rectangle box1(10.0, 10.0); // width = 10.0, length = 10.0 10 Rectangle box2 (20.0, 20.0); // width = 20.0, length = 20.0 11 12 // Display each object's width and length. 13 cout << ""..."
14.4 Copy Constructors,856,"14.4 Copy Constructors 825 The following statement, which appears in line 19, copies the width and length member variables of box1 directly into the width and length member variables of box2 : box2 = box1; Memberwise assignment also occurs when one object is initialized with another object’s values. Remember the difference between assignment and initialization: assignment occurs between two objects that already exist, and initialization happens to an object being cre- ated. Consider the following code: // Define box1. Rectangle box1(100.0, 50.0); // Define box2, initialize with box1's values Rectangle box2 = box1; The last statement defines a Rectangle object, box2 , and initializes it to the values stored in box1 . Because memberwise assignment takes place, the box2 object will contain the exact same values as the box1 object. 14.4 Copy Constructors CONCEPT: A copy constructor is a special constructor that is called whenever a new object is created and initialized with another obje..."
14.5 Operator Overloading,862,"14.5 Operator Overloading 831 14.5 Operator Overloading CONCEPT: C++ allows you to redefine how standard operators work when used with class objects. C++ provides many operators to manipulate data of the primitive data types. However, what if you wish to use an operator to manipulate class objects? For example, assume that a class named Date exists, and objects of the Date class hold the month, day, and year in member variables. Suppose the Date class has a member function named add . The add member function adds a number of days to the date and adjusts the member variables if the date goes to another month or year. For example, the following statement adds five days to the date stored in the today object: today.add(5); Although it might be obvious that the statement is adding five days to the date stored in today , the use of an operator might be more intuitive. For example, look at the following statement: today += 5; This statement uses the standard += operator to add 5 to today ..."
14.6 Object Conversion,889,"14.6 Object Conversion CONCEPT: Special operator functions may be written to convert a class object to any other type. As you’ve already seen, operator functions allow classes to work more like built-in data types. Another capability that operator functions can give classes is automatic type conversion. Data type conversion happens “behind the scenes” with the built-in data types. For instance, suppose a program uses the following variables: int i; double d; The statement below automatically converts the value in i to a floating-point number and stores it in d : d = i; Likewise, the following statement converts the value in d to an integer (truncating the frac- tional part) and stores it in i : i = d; The same functionality can also be given to class objects. For example, assuming distance is a FeetInches object and d is a double , the following statement would conveniently convert distance ’s value into a floating-point number and store it in d , if FeetInches is properly written: ..."
14.7 Aggregation,891,"14.7 Aggregation CONCEPT: Aggregation occurs when a class contains an instance of another class. In real life, objects are frequently made of other objects. A house, for example, is made of door objects, window objects, wall objects, and much more. It is the combination of all these objects that makes a house object. When designing software, it sometimes makes sense to create an object from other objects. For example, suppose you need an object to represent a course that you are taking in col- lege. You decide to create a Course class, which will hold the following information: • The course name • The instructor’s last name, first name, and office number • The textbook’s title, author, and publisher In addition to the course name, the class will hold items related to the instructor and the textbook. You could put attributes for each of these items in the Course class. However, a good design principle is to separate related items into their own classes. In this example, an Instructor..."
14.8 Focus on Object-Oriented Design: Class Collaborations,896,"4.8 Focus on Object-Oriented Design: Class Collaborations 865 14.8 Focus on Object-Oriented Design: Class Collaborations CONCEPT: It is common for classes to interact, or collaborate, with one another to perform their operations. Part of the object-oriented design process is identifying the collaborations between classes. In an object-oriented application it is common for objects of different classes to collaborate. This simply means that objects interact with each other. Sometimes one object will need the services of another object in order to fulfill its responsibilities. For example, let’s say an object needs to read a number from the keyboard and then format the number to appear as a dollar amount. The object might use the services of the cin object to read the number from the keyboard and then use the services of another object that is designed to format the number. If one object is to collaborate with another object, then it must know something about the other object’s member ..."
14.9 Focus on Object-Oriented Programming: Simulating the Game of Cho-Han,900,"14.9 Focus on Object-Oriented Programming: Simulating the Game of Cho-Han 869 When you have completed a CRC card for each class in the application, you will have a good idea of each class’s responsibilities and how the classes must interact. Checkpoint 14.31 What are the benefits of having operator functions that perform object conversion? 14.32 Why are no return types listed in the prototypes or headers of operator functions that perform data type conversion? 14.33 Assume there is a class named BlackBox . Write the header for a member function that converts a BlackBox object to an int . 14.34 Assume there are two classes, Big and Small . The Big class has, as a member, an instance of the Small class. Write a sentence that describes the relationship between the two classes. 14.9 Focus on Object-Oriented Programming: Simulating the Game of Cho-Han Cho-Han is a traditional Japanese gambling game in which a dealer uses a cup to roll two six-sided dice. The cup is placed upside down on ..."
Review Questions and Exercises,910,"Review Questions and Exercises 879 The checkGuess function, which compares a player’s guess to the dealer’s result, awarding points to the player for a correct guess, appears in lines 77 through 99. Here is a summary of the function: • The function accepts references to a Player object and the Dealer object as argu- ments. • Line 79 declares the constant POINTS_TO_ADD , set to the value 1, which is the number of points to add to the player’s balance if the player’s guess is correct. • Line 82 assigns the player’s guess to the string object guess . • Line 85 assigns the dealer’s results (Cho or Han) to the string object choHanResult . • The statement in lines 88 and 89 displays the player’s name and guess. • The if statement in line 92 compares the player’s guess to the dealer’s result. If they match, then the player guessed correctly, and line 94 awards points to the player. The displayGrandWinner function, which displays the grand winner of the game, appears in lines 105 through 13..."
15.1 What Is Inheritance?,922,"15.1 What Is Inheritance? CONCEPT: Inheritance allows a new class to be based on an existing class. The new class inherits all the member variables and functions (except the constructors and destructor) of the class it is based on. Generalization and Specialization In the real world you can find many objects that are specialized versions of other more general objects. For example, the term “insect” describes a very general type of creature with numerous characteristics. Because grasshoppers and bumblebees are insects, they have all the general characteristics of an insect. In addition, they have special characteristics of their own. For example, the grasshopper has its jumping ability, and the bumblebee has its stinger. Grasshoppers and bumblebees are specialized versions of an insect. This is illus- trated in Figure 15-1 . Inheritance, Polymorphism, and Virtual Functions 15 TOPICS 15.1 What Is Inheritance? 15.2 Protected Members and Class Access 15.3 Constructors and Destructors in..."
15.2 Protected Members and Class Access,931,"15.2 Protected Members and Class Access CONCEPT: Protected members of a base class are like private members, but they may be accessed by derived classes. The base class access specification determines how private, public, and protected base class members are accessed when they are inherited by the derived classes. Until now you have used two access specifications within a class: private and public . C++ provides a third access specification, protected . Protected members of a base class are like private members, except they may be accessed by functions in a derived class. To the rest of the program, however, protected members are inaccessible. The following code shows a modified version of the GradedActivity class declaration. The private member of the class has been made protected. This file is stored in the Student Source Code Folder Chapter 15 \ GradedActivity Version 2 . The implementation file, GradedActivity.cpp has not changed, so it is not shown again in this example. Conten..."
15.3 Constructors and Destructors in Base and Derived Classes,937,"15.3 Constructors and Destructors in Base and Derived Classes CONCEPT: The base class’s constructor is called before the derived class’s constructor. The destructors are called in reverse order, with the derived class’s destructor being called first. In inheritance, the base class constructor is called before the derived class constructor. Destructors are called in reverse order. Program 15-4 shows a simple set of demonstration classes, each with a default constructor and a destructor. The DerivedClass class is derived from the BaseClass class. Messages are displayed by the constructors and destructors to demonstrate when each is called. Program 15-4 1 // This program demonstrates the order in which base and 2 // derived class constructors and destructors are called. 3 #include <iostream> 4 using namespace std; 5 6 //******************************** 7 // BaseClass declaration * 8 //******************************** 9 15.3 Constructors and Destructors in Base and Derived Classes 907 1..."
15.4 Redefining Base Class Functions,949,"15.4 Redefining Base Class Functions CONCEPT: A base class member function may be redefined in a derived class. Inheritance is commonly used to extend a class or give it additional capabilities. Sometimes it may be helpful to overload a base class function with a function of the same name in the derived class. For example, recall the GradedActivity class that was presented earlier in this chapter: class GradedActivity { protected: char letter; // To hold the letter grade double score; // To hold the numeric score void determineGrade(); // Determines the letter grade VideoNote Redefi ning a Base Class Function in a Derived Class 15.4 Redefining Base Class Functions 919 public: // Default constructor GradedActivity() { letter = ' '; score = 0.0; } // Mutator function void setScore(double s) { score = s; determineGrade(); } // Accessor functions double getScore() const { return score; } char getLetterGrade() const { return letter; } }; This class holds a numeric score and determines a ..."
15.5 Class Hierarchies,954,"15.5 Class Hierarchies 923 25 26 b.showMessage(); 27 d.showMessage(); 28 29 return 0; 30 } Program Output This is the Base class. This is the Derived class. In Program 15-8 , a class named BaseClass is declared with a member function named showMessage . A class named DerivedClass is then declared, also with a showMessage member function. As their names imply, DerivedClass is derived from BaseClass . Two objects, b and d , are defined in function main . The object b is a BaseClass object, and d is a DerivedClass object. When b is used to call the showMessage function, it is the BaseClass version that is executed. Likewise, when d is used to call showMessage , the DerivedClass version is used. 15.5 Class Hierarchies CONCEPT: A base class can also be derived from another class. Sometimes it is desirable to establish a hierarchy of classes in which one class inherits from a second class, which in turn inherits from a third class, as illustrated by Figure 15-4 . In some cases, the inheri..."
15.6 Polymorphism and Virtual Member Functions,960,"15.6 Polymorphism and Virtual Member Functions 929 15.6 Polymorphism and Virtual Member Functions CONCEPT: Polymorphism allows an object reference variable or an object pointer to reference objects of different types and to call the correct member functions, depending upon the type of object being referenced. Look at the following code for a function named displayGrade : void displayGrade(const GradedActivity &activity) { cout << setprecision(1) << fixed; cout << ""The activity's numeric score is "" << activity.getScore() << endl; cout << ""The activity's letter grade is "" << activity.getLetterGrade() << endl; } This function uses a const GradedActivity reference variable as its parameter. When a GradedActivity object is passed as an argument to this function, the function calls the object’s getScore and getLetterGrade member functions to display the numeric score and letter grade. The following code shows how we might call the function. GradedActivity test(88.0); // The score is 88 di..."
15.7 Abstract Base Classes and Pure Virtual Functions,976,"15.7 Abstract Base Classes and Pure Virtual Functions 945 15 virtual void functionA(int arg) const override 16 { cout << ""This is Derived::functionA"" << endl; } 17 }; 18 19 int main() 20 { 21 // Allocate instances of the Derived class. 22 Base *b = new Derived(); 23 Derived *d = new Derived(); 24 25 // Call functionA with the two pointers. 26 b->functionA(99); 27 d->functionA(99); 28 29 return 0; 30 } Program Output This is Derived::functionA This is Derived::functionA Preventing a Member Function from Being Overridden In some derived classes, you might want to make sure that a virtual member function cannot be overridden any further down the class hierarchy. When a member function is declared with the final key word, it cannot be overridden in a derived class. The following member function prototype is an example that uses the final key word: virtual void message() const final; If a derived class attempts to override a final member function, the compiler generates an error. 15.7 Ab..."
15.8 Multiple Inheritance,983,"15.8 Multiple Inheritance CONCEPT: Multiple inheritance is when a derived class has two or more base classes. Previously we discussed how a class may be derived from a second class that is itself derived from a third class. The series of classes establishes a chain of inheritance. In such a scheme, you might be tempted to think of the lowest class in the chain as having multiple base classes. A base class, however, should be thought of as the class that another class is directly 15.8 Multiple Inheritance 953 derived from. Even though there may be several classes in a chain, each class (below the topmost class) only has one base class. Another way of combining classes is through multiple inheritance. Multiple inheritance is when a class has two or more base classes. This is illustrated in Figure 15-6 . Class A Class B Class C Figure 15-6 In Figure 15-6 , class C is directly derived from classes A and B and inherits the members of both. Neither class A nor B, however, inherits members..."
Review Questions and Exercises,990,"Review Questions and Exercises Short Answer 1. What is an “is a” relationship? 2. A program uses two classes: Dog and Poodle . Which class is the base class and which is the derived class? 3. How does base class access specification differ from class member access specifica- tion? 4. What is the difference between a protected class member and a private class member? 5. Can a derived class ever directly access the private members of its base class? 6. Which constructor is called first, that of the derived class or the base class? 7. What is the difference between redefining a base class function and overriding a base class function? 8. When does static binding take place? When does dynamic binding take place? 9. What is an abstract base class? 10. A program has a class Potato , which is derived from the class Vegetable , which is derived from the class Food . Is this an example of multiple inheritance? Why or why not? 11. What base class is named in the line below? class Pet : public..."
"CHAPTER 16 Exceptions, Templates, and the Standard Template Library (STL)",1002,"16.1 Exceptions CONCEPT: Exceptions are used to signal errors or unexpected events that occur while a program is running. Error testing is usually a straightforward process involving if statements or other control mechanisms. For example, the following code segment will trap a division-by-zero error before it occurs: if (denominator == 0) cout << ""ERROR: Cannot divide by zero.\n""; else quotient = numerator / denominator; But what if similar code is part of a function that returns the quotient, as in the following example? // An unreliable division function double divide(int numerator, int denominator) { if (denominator == 0) { cout << ""ERROR: Cannot divide by zero.\n""; return 0; } else return static_cast<double>(numerator) / denominator; } Exceptions, Templates, and the Standard Template Library (STL) 16 TOPICS 16.1 Exceptions 16.2 Function Templates 16.3 Focus on Software Engineering: Where to Start When Defining Templates 16.4 Class Templates 16.5 Introduction to the Standard Temp..."
16.1 Exceptions,1002,"16.1 Exceptions CONCEPT: Exceptions are used to signal errors or unexpected events that occur while a program is running. Error testing is usually a straightforward process involving if statements or other control mechanisms. For example, the following code segment will trap a division-by-zero error before it occurs: if (denominator == 0) cout << ""ERROR: Cannot divide by zero.\n""; else quotient = numerator / denominator; But what if similar code is part of a function that returns the quotient, as in the following example? // An unreliable division function double divide(int numerator, int denominator) { if (denominator == 0) { cout << ""ERROR: Cannot divide by zero.\n""; return 0; } else return static_cast<double>(numerator) / denominator; } Exceptions, Templates, and the Standard Template Library (STL) 16 TOPICS 16.1 Exceptions 16.2 Function Templates 16.3 Focus on Software Engineering: Where to Start When Defining Templates 16.4 Class Templates 16.5 Introduction to the Standard Temp..."
16.2 Function Templates,1021,"16.2 Function Templates CONCEPT: A function template is a “generic” function that can work with any data type. The programmer writes the specifications of the function, but substi- tutes parameters for data types. When the compiler encounters a call to the function, it generates code to handle the specific data type(s) used in the call. Introduction Overloaded functions make programming convenient because only one function name must be remembered for a set of functions that perform similar operations. Each of the functions, however, must still be written individually, even if they perform the same operation. For example, suppose a program uses the following overloaded square functions. int square(int number) { return number * number; } double square(double number) { return number * number; } The only differences between these two functions are the data types of their return values and their parameters. In situations like this, it is more convenient to write a function tem- plate tha..."
16.3 Focus on Software Engineering: Where to Start When Defining Templates,1027,"16.3 Focus on Software Engineering: Where to Start When Defining Templates Quite often, it is easier to convert an existing function into a template than to write a tem- plate from scratch. With this in mind, you should start designing a function template by writing it first as a regular function. For example, the swapVars template in Program 16-8 would have been started as something like the following: void swapVars(int &var1, int &var2) { int temp; temp = var1; var1 = var2; var2 = temp; } Once this function is properly tested and debugged, converting it to a template is a simple process. First, the template <class T> header is added, then all the references to int that must be changed are replaced with the data type parameter T . Checkpoint 16.6 When does the compiler actually generate code for a function template? 16.7 The following function accepts an int argument and returns half of its value as a double : double half(int number) { return number / 2.0; } Write a template that w..."
16.4 Class Templates,1027,"16.4 Class Templates CONCEPT: Templates may also be used to create generic classes and abstract data types. Class templates allow you to create one general version of a class without having to duplicate code to handle multiple data types. Recall the IntArray class from Chapter 14 . By overloading the [] operator, this class allows you to implement int arrays that perform bounds checking. But suppose you would like to have a version of this class for other data types? Of course, you could design specialized classes such as LongArray , FloatArray , DoubleArray , and so forth. A better solution, how- ever, is to design a single class template that works with any primitive data type. In this sec- tion, we will convert the IntArray class into a generalized template named SimpleVector ."
16.5 Introduction to the Standard Template Library (STL),1036,"16.5 Introduction to the Standard Template Library (STL) 1005 In the declaration, the actual data type is used instead of a type parameter. For example, the declaration of a specialized version of the SimpleVector class might start like this: class SimpleVector<char *> The compiler would know that this version of the SimpleVector class is intended for the char * data type. Anytime an object is defined of the type SimpleVector<char *> , the compiler will use this template to generate the code. Checkpoint 16.10 Suppose your program uses a class template named List , which is defined as template<class T> class List { // Members are declared here... }; Give an example of how you would use int as the data type in the definition of a List object. (Assume the class has a default constructor.) 16.11 As the following Rectangle class is written, the width and length members are double s. Rewrite the class as a template that will accept any data type for these members. class Rectangle { privat..."
Review Questions and Exercises,1050,"Review Questions and Exercises Short Answer 1. What is a throw point? 2. What is an exception handler? 3. Explain the difference between a try block and a catch block. 4. What happens if an exception is thrown, but not caught? 5. What is “unwinding the stack”? 6. What happens if an exception is thrown by a class’s member function? 7. How do you prevent a program from halting when the new operator fails to allocate memory? 8. Why is it more convenient to write a function template than a series of overloaded functions? 9. Why must you be careful when writing a function template that uses operators such as [] with its parameters? 10. What is a container? What is an iterator? 11. What two types of containers does the STL provide? 12. What STL algorithm randomly shuffles the elements in a container? Fill-in-the-Blank 13. The line containing a throw statement is known as the __________. 14. The __________ block contains code that directly or indirectly might cause an excep- tion to be thr..."
17.1 Introduction to the Linked List ADT,1056,"17.1 Introduction to the Linked List ADT CONCEPT: Dynamically allocated data structures may be linked together in memory to form a chain. A linked list is a series of connected nodes, where each node is a data structure. A linked list can grow or shrink in size as the program runs. This is possible because the nodes in a linked list are dynamically allocated. If new data need to be added to a linked list, the pro- gram simply allocates another node and inserts it into the series. If a particular piece of data needs to be removed from the linked list, the program deletes the node containing that data. Advantages of Linked Lists over Arrays and vector s Although linked lists are more complex to code and manage than arrays, they have some distinct advantages. First, a linked list can easily grow or shrink in size. In fact, the program- mer doesn’t need to know how many nodes will be in the list. They are simply created in memory as they are needed. One might argue that linked lists are..."
17.2 Linked List Operations,1058,"17.2 Linked List Operations 1027 Because the ListNode structure contains a pointer to an object of the same type as that being declared, it is known as a self-referential data structure . This structure makes it pos- sible to create nodes that point to other nodes of the same type. The next step is to define a pointer to serve as the list head, as shown here. ListNode *head; Before you use the head pointer in any linked list operations, you must be sure it is initial- ized to nullptr because that marks the end of the list. Once you have declared a node data structure and have created a null head pointer, you have an empty linked list. The next step is to implement operations with the list. Checkpoint 17.1 Describe the two parts of a node. 17.2 What is a list head? 17.3 What signifies the end of a linked list? 17.4 What is a self-referential data structure? 17.2 Linked List Operations CONCEPT: The basic linked list operations are appending a node, traversing the list, inserting a nod..."
17.3 A Linked List Template,1074,"17.3 A Linked List Template 1043 167 NumberList::~NumberList() 168 { 169 ListNode *nodePtr; // To traverse the list 170 ListNode *nextNode; // To point to the next node 171 172 // Position nodePtr at the head of the list. 173 nodePtr = head; 174 175 // While nodePtr is not at the end of the list... 176 while (nodePtr != nullptr) 177 { 178 // Save a pointer to the next node. 179 nextNode = nodePtr->next; 180 181 // Delete the current node. 182 delete nodePtr; 183 184 // Position nodePtr at the next node. 185 nodePtr = nextNode; 186 } 187 } Notice the use of nextNode instead of previousNode . The nextNode pointer is used to hold the position of the next node in the list, so that it will be available after the node pointed to by nodePtr is deleted. Checkpoint 17.8 What are the two steps involved in deleting a node from a linked list? 17.9 When deleting a node, why can’t you just use the delete operator to remove it from memory? Why must you take the steps you listed in response to Ques..."
17.4 Variations of the Linked List,1086,"17.4 Variations of the Linked List 1055 225 226 // Delete the current node. 227 delete nodePtr; 228 229 // Position nodePtr at the next node. 230 nodePtr = nextNode; 231 } 232 } 233 #endif 17.4 Variations of the Linked List CONCEPT: There are many ways to link dynamically allocated data structures together. Two variations of the linked list are the doubly linked list and the circular linked list. The linked list examples that we have discussed are considered singly linked lists . Each node is linked to a single other node. A variation of this is the doubly linked list . In this type of list, each node points not only to the next node, but also to the previous one. This is illustrated in Figure 17-18 . List Head Pointer Pointer Pointer Pointer Pointer Pointer null null Figure 17-18 In Figure 17-18 , the last node and the first node in the list have pointers to the null address. When the program traverses the list it knows when it has reached either end. Another variation is the circu..."
17.5 The STL list Container,1087,"17.5 The STL list Container CONCEPT: The Standard Template Library provides a linked list container. The list container, found in the Standard Template Library, is a template version of a dou- bly linked list. STL list s can insert elements or add elements to their front quicker than vector s can because list s do not have to shift the other elements. list s are also efficient at adding elements at their back because they have a built-in pointer to the last element in the list (no traversal required). Table 17-1 describes some of the list member functions. Table 17-1 Member Function Examples and Description back cout << list.back() << endl; The back member function returns a reference to the last element in the list. empty if (list.empty()) The empty member function returns true if the list is empty. If the list has elements, it returns false . end iter = list.end(); end returns a bidirectional iterator to the end of the list. erase list.erase(iter); list.erase(firstIter, lastIter) ..."
Review Questions and Exercises,1089,Review Questions and Exercises Short Answer 1. What are some of the advantages that linked lists have over arrays? 2. What advantage does a linked list have over the STL vector ? 3. What is a list head? 4. What is a self-referential data structure? 5. How is the end of a linked list usually signified? 6. Name five basic linked list operations. 7. What is the difference between appending a node and inserting a node? 8. What does “traversing the list” mean? 9. What are the two steps required to delete a node from a linked list? 10. What is the advantage of using a template to implement a linked list? 11. What is a singly linked list? What is a doubly linked list? What is a circularly linked list? 12. What type of linked list is the STL list container? Fill-in-the-Blank 13. The __________ points to the first node in a linked list. 14. A data structure that points to an object of the same type as itself is known as a(n) __________ data structure. 15. After creating a linked list’s head ...
18.1 Introduction to the Stack ADT,1094,"18.1 Introduction to the Stack ADT CONCEPT: A stack is a data structure that stores and retrieves items in a last-in-first- out manner. Definition Like an array or a linked list, a stack is a data structure that holds a sequence of elements. Unlike arrays and lists, however, stacks are last-in, first-out (LIFO) structures. This means that when a program retrieves elements from a stack, the last element inserted into the stack is the first one retrieved (and likewise, the first element inserted is the last one retrieved). When visualizing the way a stack works, think of a stack of plates at the beginning of a cafeteria line. When a cafeteria worker replenishes the supply of plates, the first one he or she puts on the stack is the last one taken off. This is illustrated in Figure 18-1 . Stacks and Queues 18 TOPICS 18.1 Introduction to the Stack ADT 18.2 Dynamic Stacks 18.3 The STL stack Container 18.4 Introduction to the Queue ADT 18.5 Dynamic Queues 18.6 The STL deque and queue Conta..."
18.2 Dynamic Stacks,1111,"18.2 Dynamic Stacks CONCEPT: A stack may be implemented as a linked list and expand or shrink with each push or pop operation. A dynamic stack is built on a linked list instead of an array. A linked list–based stack offers two advantages over an array-based stack. First, there is no need to specify the starting size of the stack. A dynamic stack simply starts as an empty linked list, then expands by one node each time a value is pushed. Second, a dynamic stack will never be full, as long as the system has enough free memory. In this section we will look at a dynamic stack class, DynIntStack . This class is a dynamic version of the IntStack class previously discussed. The class declaration is shown here: 18.2 Dynamic Stacks 1081 Contents of DynIntStack.h 1 // Specification file for the DynIntStack class 2 #ifndef DYNINTSTACK_H 3 #define DYNINTSTACK_H 4 5 class DynIntStack 6 { 7 private: 8 // Structure for stack nodes 9 struct StackNode 10 { 11 int value; // Value in the node 12 Stack..."
18.3 The STL stack Container,1122,"18.3 The STL stack Container 1091 18.3 The STL stack Container CONCEPT: The Standard Template Library offers a stack template, which may be implemented as a vector , a list , or a deque . So far, the STL containers you have learned about are vector s and list s. The STL stack container may be implemented as a vector or a list . (It may also be implemented as a deque , which you will learn about later in this chapter.) Because the stack container is used to adapt these other containers, it is often referred to as a container adapter . Here are examples of how to define a stack of int s, implemented as a vector , a list , and a deque . stack<int, vector<int>> iStack; // Vector stack stack<int, list<int>> iStack; // List stack stack<int> iStack; // Default − deque stack VideoNote Storing Objects in an STL stack NOTE: If you are using a compiler that is older than C++ 11, be sure to put spaces between the angled brackets that appear next to each other. Older compilers will mis- take the..."
18.4 Introduction to the Queue ADT,1124,"18.4 Introduction to the Queue ADT 1093 18.4 Introduction to the Queue ADT CONCEPT: A queue is a data structure that stores and retrieves items in a first-in- first-out manner. Definition Like a stack, a queue (pronounced ""cue"") is a data structure that holds a sequence of ele- ments. A queue, however, provides access to its elements in first-in , first-out (FIFO) order. The elements in a queue are processed like customers standing in a grocery checkout line: The first customer in line is the first one served. Application of Queues Queue data structures are commonly used in computer operating systems. They are espe- cially important in multiuser/multitasking environments where several users or tasks may be requesting the same resource simultaneously. Printing, for example, is controlled by a queue because only one document may be printed at a time. A queue is used to hold print jobs submitted by users of the system, while the printer services those jobs one at a time. Communications..."
18.5 Dynamic Queues,1136,"18.5 Dynamic Queues 1105 18.5 Dynamic Queues CONCEPT: A queue may be implemented as a linked list and expand or shrink with each enqueue or dequeue operation. Dynamic queues, which are built around linked lists, are much more intuitive to understand than static queues. A dynamic queue starts as an empty linked list. With the first enqueue operation, a node is added, which is pointed to by the front and rear pointers. As each new item is added to the queue, a new node is added to the rear of the list, and the rear pointer is updated to point to the new node. As each item is dequeued, the node pointed to by the front pointer is deleted, and front is made to point to the next node in the list. Figure 18-14 shows the structure of a dynamic queue. null front rear Figure 18-14 A dynamic integer queue class is listed here. Contents of DynIntQueue.h 1 #ifndef DYNINTQUEUE_H 2 #define DYNINTQUEUE_H 3 4 class DynIntQueue 5 { 6 private: 7 // Structure for the queue nodes 8 struct QueueNode 9 { ..."
18.6 The STL deque and queue Containers,1143,"18.6 The STL deque and queue Containers CONCEPT: The Standard Template Library provides two containers, deque and queue , for implementing queue-like data structures. In this section we will examine two ADTs offered by the Standard Template Library: deque and queue . A deque (pronounced “deck” or “deek”) is a double-ended queue. It is similar to a vector , but allows efficient access to values at both the front and the rear. The queue ADT is like the stack ADT: It is actually a container adapter. The deque Container Think of the deque container as a vector that provides quick access to the element at its front as well as at the back. (Like vector , deque also provides access to its elements with the [] operator.) 18.6 The STL deque and queue Containers 1113 Programs that use the deque ADT must include the deque header. Because we are con- centrating on its queue-like characteristics, we will focus our attention on the push_back , pop_front , and front member functions. Table 18-4 de..."
Review Questions and Exercises,1146,"Review Questions and Exercises 1115 25 { 26 cout << ""Popping ""<< iQueue.front() << endl; 27 iQueue.pop(); 28 } 29 return 0; 30 } Program Output I will now enqueue items... Pushing 2 Pushing 4 Pushing 6 I will now dequeue items... Popping 2 Popping 4 Popping 6 Review Questions and Exercises Short Answer 1. What does LIFO mean? 2. What element is always retrieved from a stack? 3. What is the difference between a static stack and a dynamic stack? 4. Describe two operations that all stacks perform. 5. Describe two operations that static stacks must perform. 6. The STL stack is considered a container adapter. What does that mean? 7. What types may the STL stack be based on? By default, what type is an STL stack based on? 8. What does FIFO mean? 9. When an element is added to a queue, where is it added? 10. When an element is removed from a queue, where is it removed from? 11. Describe two operations that all queues perform. 12. What two queue-like containers does the STL offer? Fill-in-t..."
19.1 Introduction to Recursion,1152,"19.1 Introduction to Recursion CONCEPT: A recursive function is one that calls itself. You have seen instances of functions calling other functions. Function A can call function B, which can then call function C. It’s also possible for a function to call itself. A function that calls itself is a recursive function . Look at this message function: void message() { cout << ""This is a recursive function.\n""; message(); } This function displays the string “This is a recursive function.\n”, and then calls itself. Each time it calls itself, the cycle is repeated. Can you see a problem with the function? There’s no way to stop the recursive calls. This function is like an infinite loop because there is no code to stop it from repeating. Recursion 19 TOPICS 19.1 Introduction to Recursion 19.2 Solving Problems with Recursion 19.3 Focus on Problem Solving and Program Design: The Recursive gcd Function 19.4 Focus on Problem Solving and Program Design: Solving Recursively Defined Problems 19.5 ..."
19.2 Solving Problems with Recursion,1156,"19.2 Solving Problems with Recursion 1125 14 //************************************************************* 15 // Definition of function message. If the value in times is * 16 // greater than 0, the message is displayed and the function * 17 // is recursively called with the argument times − 1. * 18 //************************************************************* 19 20 void message(int times) 21 { 22 cout << ""message called with "" << times << "" in times.\n""; 23 24 if (times > 0) 25 { 26 cout << ""This is a recursive function.\n""; 27 message(times − 1); 28 } 29 30 cout << ""message returning with "" << times; 31 cout << "" in times.\n""; 32 } Program Output message called with 5 in times. This is a recursive function. message called with 4 in times. This is a recursive function. message called with 3 in times. This is a recursive function. message called with 2 in times. This is a recursive function. message called with 1 in times. This is a recursive function. message called with 0 in ti..."
19.3 Focus on Problem Solving and Program Design: The Recursive gcd Function,1164,"19.3 Focus on Problem Solving and Program Design: The Recursive gcd Function 1133 (program continues) 19.3 Focus on Problem Solving and Program Design: The Recursive gcd Function CONCEPT: The gcd function uses recursion to find the greatest common divisor (GCD) of two numbers. Our next example of recursion is the calculation of the greatest common divisor, or GCD, of two numbers. Using Euclid’s algorithm, the GCD of two positive integers, x and y , is: gcd( x , y ) = y ; if y divides x evenly gcd( y , remainder of x / y ); otherwise The definition above states that the GCD of x and y is y if x / y has no remainder. Otherwise, the answer is the GCD of y and the remainder of x / y . Program 19-5 shows the recursive C++ implementation: Program 19-5 1 // This program demonstrates a recursive function to calculate 2 // the greatest common divisor (gcd) of two numbers. 3 #include <iostream> 4 using namespace std; 5 6 // Function prototype 7 int gcd(int, int); 8 9 int main() 10 { 11 int nu..."
19.4 Focus on Problem Solving and Program Design: Solving Recursively Defined Problems,1165,"19.4 Focus on Problem Solving and Program Design: Solving Recursively Defined Problems CONCEPT: Some mathematical problems are designed for a recursive solution. Some mathematical problems are designed to be solved recursively. One well-known exam- ple is the calculation of Fibonacci numbers. The Fibonacci numbers, named after the Italian mathematician Leonardo Fibonacci (born circa 1170), are the following sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, . . . Notice that after the second number, each number in the series is the sum of the two previ- ous numbers. The Fibonacci series can be defined as F 0 = 0 F 1 = 1 F N = F N −1 + F N −2 for N ≥ 2. A recursive C++ function to calculate the n th number in the Fibonacci series is shown here: int fib(int n) { if (n <= 0) return 0; else if (n == 1) return 1; else return fib(n − 1) + fib(n − 2); } The function is demonstrated in Program 19-6 , which displays the first 10 numbers in the Fibonacci series. Program 19-6 1 // Th..."
19.5 Focus on Problem Solving and Program Design: Recursive Linked List Operations,1166,"19.5 Focus on Problem Solving and Program Design: Recursive Linked List Operations 1135 6 // Function prototype 7 int fib(int); 8 9 int main() 10 { 11 cout << ""The first 10 Fibonacci numbers are:\n""; 12 for (int x = 0; x < 10; x++) 13 cout << fib(x) << "" ""; 14 cout << endl; 15 return 0; 16 } 17 18 //***************************************** 19 // Function fib. Accepts an int argument * 20 // in n. This function returns the nth * 21 // Fibonacci number. * 22 //***************************************** 23 24 int fib(int n) 25 { 26 if (n <= 0) 27 return 0; // Base case 28 else if (n == 1) 29 return 1; // Base case 30 else 31 return fib(n − 1) + fib(n − 2); // Recursive case 32 } Program Output The first 10 Fibonacci numbers are: 0 1 1 2 3 5 8 13 21 34 Another such example is Ackermann’s function. A Programming Challenge at the end of this chapter asks you to write a recursive function that calculates Ackermann’s function. 19.5 Focus on Problem Solving and Program Design: Recursive Link..."
19.6 Focus on Problem Solving and Program Design: A Recursive Binary Search Function,1170,"19.6 Focus on Problem Solving and Program Design: A Recursive Binary Search Function 1139 Program Output Here are the values in the list: 1.5 2.6 3.7 4.8 5.9 7 8.1 9.2 Here are the values in reverse order: 9.2 8.1 7 5.9 4.8 3.7 2.6 1.5 19.6 Focus on Problem Solving and Program Design: A Recursive Binary Search Function CONCEPT: The binary search algorithm can be defined as a recursive function. In Chapter 8 you learned about the binary search algorithm and saw an iterative exam- ple written in C++. The binary search algorithm can also be implemented recursively. For example, the procedure can be expressed as If array[middle] equals the search value, then the value is found. Else, if array[middle] is less than the search value, perform a binary search on the upper half of the array. Else, if array[middle] is greater than the search value, perform a binary search on the lower half of the array. The recursive binary search algorithm is an example of breaking a problem down into smaller..."
19.7 The Towers of Hanoi,1172,"19.7 The Towers of Hanoi 1141 55 if (array[middle]==value) 56 return middle; 57 if (array[middle]<value) 58 return binarySearch(array, middle+1,last,value); 59 else 60 return binarySearch(array, first,middle-1,value); 61 } Program Output with Example Input Shown in Bold Enter the Employee ID you wish to search for: 521 [Enter] That ID is found at element 17 in the array 19.7 The Towers of Hanoi CONCEPT: The repetitive steps involved in solving the Towers of Hanoi game can be easily implemented in a recursive algorithm. The Towers of Hanoi is a mathematical game that is often used in computer science text- books to illustrate the power of recursion. The game uses three pegs and a set of discs with holes through their centers. The discs are stacked on one of the pegs as shown in Figure 19-4 . Figure 19-4 The pegs and discs in the Towers of Hanoi game Notice that the discs are stacked on the leftmost peg, in order of size with the largest disc at the bottom. The game is based on a lege..."
19.8 Focus on Problem Solving and Program Design: The QuickSort Algorithm,1175,"19.8 Focus on Problem Solving and Program Design: The QuickSort Algorithm CONCEPT: The QuickSort algorithm uses recursion to efficiently sort a list. The QuickSort algorithm is a popular general-purpose sorting routine developed in 1960 by C.A.R. Hoare. It can be used to sort lists stored in arrays or linear linked lists. It sorts a list by dividing it into two sublists. Between the sublists is a selected value known as the pivot . This is illustrated in Figure 19-6 . Notice in the figure that sublist 1 is positioned to the left of (before) the pivot, and sublist 2 is positioned to the right of (after) the pivot. Once a pivot value has been selected, the algo- rithm exchanges the other values in the list until all the elements in sublist 1 are less than the pivot, and all the elements in sublist 2 are greater than the pivot. Program 19-10 (continued) 19.8 Focus on Problem Solving and Program Design: The QuickSort Algorithm 1145 Once this is done, the algorithm repeats the procedure ..."
19.9 Exhaustive Algorithms,1179,"19.9 Exhaustive Algorithms CONCEPT: An exhaustive algorithm is one that finds a best combination of items by looking at all the possible combinations. Recursion is helpful if you need to examine many possible combinations and identify the best combination. For example, consider all the different ways you can make change for $1.00 using our system of coins: 1 dollar piece, or 2 fifty-cent pieces, or 4 quarters, or 1 fifty-cent piece and 2 quarters, or 3 quarters, 2 dimes, and 1 nickel, or … there are many more possibilities. Although there are many ways to make change for $1.00, some ways are better than others. For example, you would probably rather give a single dollar piece instead of 100 pennies. An algorithm that looks at all the possible combinations of items in order to find the best combination of items is called an exhaustive algorithm. Program 19-12 presents a recursive function that exhaustively tries all the possible combinations of coins. The program then displays the to..."
19.10 Focus on Software Engineering: Recursion vs. Iteration,1182,"19.10 Focus on Software Engineering: Recursion vs. Iteration CONCEPT: Recursive algorithms can also be coded with iterative control structures. There are advantages and disadvantages to each approach. Any algorithm that can be coded with recursion can also be coded with an iterative control structure, such as a while loop. Both approaches achieve repetition, but which is best to use? There are several reasons not to use recursion. Recursive algorithms are certainly less efficient than iterative algorithms. Each time a function is called, the system incurs overhead that is not necessary with a loop. Also, in many cases an iterative solution may be more evident than a recursive one. In fact, the majority of repetitive programming tasks are best done with loops. Some problems, however, are more easily solved with recursion than with iteration. For example, the mathematical definition of the GCD formula is well-suited for a recursive approach. The QuickSort algorithm is also an example ..."
Review Questions and Exercises,1182,"Review Questions and Exercises 1151 Program Output with Example Input Shown in Bold Here are the valid coin values, in cents: 100 50 25 10 5 1 Enter the amount of cents (as an integer) to make change for: 62 [Enter] What is the maximum number of coins to give as change? 6 [Enter] Number of possible combinations: 77 Best combination of coins: 50 10 1 1 19.10 Focus on Software Engineering: Recursion vs. Iteration CONCEPT: Recursive algorithms can also be coded with iterative control structures. There are advantages and disadvantages to each approach. Any algorithm that can be coded with recursion can also be coded with an iterative control structure, such as a while loop. Both approaches achieve repetition, but which is best to use? There are several reasons not to use recursion. Recursive algorithms are certainly less efficient than iterative algorithms. Each time a function is called, the system incurs overhead that is not necessary with a loop. Also, in many cases an iterative solu..."
20.1 Definition and Applications of Binary Trees,1186,"20.1 Definition and Applications of Binary Trees CONCEPT: A binary tree is a nonlinear linked structure in which each node may point to two other nodes, and every node but the root node has a single predecessor. Binary trees expedite the process of searching large sets of data. A standard linked list is a linear data structure in which one node is linked to the next. A binary tree is a nonlinear linked structure. It is nonlinear because each node can point to two other nodes. Figure 20-1 illustrates the organization of a binary tree. The data structure is called a tree because it resembles an upside-down tree. It is anchored at the top by a tree pointer , which is like the head pointer in a standard linked list. The first node in the list is called the root node . The root node has pointers to two other nodes, which are called children , or child nodes . Each of the children has its own set of two point- ers and can have its own children. Notice that not all nodes have two children...."
20.2 Binary Search Tree Operations,1189,"20.2 Binary Search Tree Operations CONCEPT: There are many operations that may be performed on a binary search tree. In this section we will discuss creating a binary search tree and inserting, finding, and deleting nodes. In this section you will learn some basic operations that may be performed on a binary search tree. We will study a simple class that implements a binary tree for storing integer values. null Pointer Pointer Pointer Pointer Pointer Pointer Pointer Pointer Pointer Pointer null null null null null Tree Pointer M R F B P 1 2 3 Figure 20-4 20.2 Binary Search Tree Operations 1159 Creating a Binary Tree We will demonstrate the fundamental binary tree operations using a simple ADT: the IntBinaryTree class. The basis of our binary tree node is the following struct declaration: struct TreeNode { int value; TreeNode *left; TreeNode *right; }; Each node has a value member for storing its integer data, as well as left and right pointers. The struct is implemented in the class..."
20.3 Template Considerations for Binary Search Trees,1206,"20.3 Template Considerations for Binary Search Trees 1175 163 164 //************************************************************* 165 // The displayPreOrder member function displays the values * 166 // in the subtree pointed to by nodePtr, via preorder traversal. * 167 //************************************************************* 168 169 void IntBinaryTree::displayPreOrder(TreeNode *nodePtr) const 170 { 171 if (nodePtr) 172 { 173 cout << nodePtr->value << endl; 174 displayPreOrder(nodePtr->left); 175 displayPreOrder(nodePtr->right); 176 } 177 } 178 179 //************************************************************* 180 // The displayPostOrder member function displays the values * 181 // in the subtree pointed to by nodePtr, via postorder traversal. * 182 //************************************************************* 183 184 void IntBinaryTree::displayPostOrder(TreeNode *nodePtr) const 185 { 186 if (nodePtr) 187 { 188 displayPostOrder(nodePtr->left); 189 displayPostOrder(nodePtr->..."
Review Questions and Exercises,1212,"Review Questions and Exercises 1181 Program Output with Example Input Shown in Bold Enter a name: David [Enter] Enter a name: Geri [Enter] Enter a name: Chris [Enter] Enter a name: Samantha [Enter] Enter a name: Anthony [Enter] Here are the values in the tree: Anthony Chris David Geri Samantha Review Questions and Exercises Short Answer 1. Each node in a binary tree may point to how many other nodes? 2. How many predecessors may each node other than the root node have? 3. What is a leaf node? 4. What is a subtree? 5. What initially determines the shape of a binary tree? 6. What are the three methods of traversing a binary tree? What is the difference between these methods? Fill-in-the-Blank 7. The first node in a binary tree is called the __________. 8. A binary tree node’s left and right pointers point to the node’s __________. 9. A node with no children is called a(n) __________. 10. A(n) __________ is an entire branch of the tree, from one particular node down. 11. The three comm..."
A: Getting Started with Alice,1216,"Getting Started with Alice 2 Alice is an innovative software system that allows you to create 3D animations and computer games while learning fundamental programming concepts. With Alice you place graphical objects such as people, animals, buildings, cars, and so on inside 3D virtual worlds. Then you create programming statements that make the objects perform actions. Alice’s drag- and-drop program editor makes it easy to create animations with rich interactions between objects. Downloading and Installing Alice When you extract the contents of Alice2.x.zip you will get a folder named Alice2.x. Inside this folder you will ﬁnd an executable ﬁle named Alice.exe. Double-click this ﬁle to run Alice. TIP: You will probably want to create a shortcut to the Alice.exe file on your desktop. Right-click the file and then select Send To Desktop (create shortcut) from the menu. To start Alice double-click the shortcut that appears on the desktop. Using the Welcome to Alice! Dialog Box When you s..."
B: The ASCII Character Set,1242,"The ASCII Character Set Nonprintable ASCII Characters Dec Hex Oct Name of Character 0 0 0 NULL 1 1 1 SOTT 2 2 2 STX 3 3 3 ETY 4 4 4 EOT 5 5 5 ENQ 6 6 6 ACK 7 7 7 BELL 8 8 10 BKSPC 9 9 11 HZTAB 10 a 12 NEWLN 11 b 13 VTAB 12 c 14 FF 13 d 15 CR 14 e 16 SO 15 f 17 SI 16 10 20 DLE 17 11 21 DC1 18 12 22 DC2 19 13 23 DC3 20 14 24 DC4 21 15 25 NAK 22 16 26 SYN 23 17 27 ETB 24 18 30 CAN 25 19 31 EM 26 la 32 SUB 27 lb 33 ESC 28 lc 34 FS 29 Id 35 GS 30 le 36 RS 31 If 37 US 127 7f 177 DEL Printable ASCII Characters Dec Hex Oct Character 32 20 40 (Space) 33 21 41 ! 34 22 42 “ 35 23 43 # 36 24 44 $ 37 25 45 % 38 26 46 & 39 27 47 ' 40 28 50 ( 41 29 51 ) 42 2a 52 * 43 2b 53 + 44 2c 54 , 45 2d 55 − 46 2e 56 . 47 2f 57 / 48 30 60 0 49 31 61 1 50 32 62 2 51 33 63 3 52 34 64 4 53 35 65 5 54 36 66 6 55 37 67 7 56 38 70 8 57 39 71 9 58 3a 72 : 59 3b 73 ; 60 3c 74 < 61 3d 75 = 62 3e 76 > 63 3f 77 ? 64 40 100 @ 1212 Appendix B The ASCII Character Set Printable ASCII Characters Dec Hex Oct Character 96 60 1..."
C: Operator Precedence and Associativity,1244,"Operator Precedence and Associativity The operators are shown in order of precedence, from highest to lowest. Operator Associativity :: unary: left to right binary: right to left () [] -> . left to right ++ – + - ! ~ (type) * & sizeof right to left * / % left to right + − left to right << >> left to right < <= > >= left to right == != left to right & left to right ^ left to right | left to right && left to right || left to right ?: right to left = += −= *= /= %= &= ^= |= <<= >>= right to left , left to right This page intentionally left blank"
Symbols,1248,"1218 Index arithmetic and logic unit (ALU), 5 arithmetic assignment operators, 105 arithmetic expressions, 89 – 98 arithmetic operators, 61 – 69 , 92 arrays, 375 – 443 accessing elements, 377 – 378 assigning one, to another, 398 – 399 averaging values in, 400 – 401 binary search, 460 – 463 BookInfo structure, 611 bounds checking, 384 – 386 bubble sort, 470 – 474 comparing, 403 – 404 const key word, 412 – 413 contents of, 383 – 384 described, 375 – 376 enum with, 636 – 638 from file to, 382 – 383 as function arguments, 407 – 417 highest and lowest values, 401 initialization, 387 – 392 , 613 , 767 inputting and outputting, 378 – 382 linear search, 457 – 460 linked lists vs., 1025 memory requirements of, 376 – 377 National Commerce Bank case study, 427 – 429 of objects, 767 – 768 off-by-one error, 386 – 387 parallel, 404 – 407 partially filled, 401 – 403 and pointers, 504 – 508 printing contents of, 399 – 400 processing array contents, 396 – 404 range-based for loop, 392 – 396 search a..."
J-K-L,1257,"initialization list, 388 inline expansion, 745 inline member functions, 743 – 745 inorder traversal, binary trees, 1163 input, 17 – 18 array contents, 378 – 382 with cin, 83 – 87 reading, into string objects, 581 input devices, 7 input file, 265 , 268 input iterators, 1007 input–output stream library, 36 input validation and decision making, 193 – 194 and while loops, 239 – 241 insert member function list, 1056 string class, 590 vector, 1012 instances of class, 715 of classes, 723 – 733 of structures, 604 variables, 811 – 812 instantiation, 723 int, 43 , 44 , 634 integer data types, 42 – 47 integer division, 62 , 64 , 99 integer flags, 182 IntegerList class, 782 – 785 integer literals, 46 integer variables, 56 – 57 integrated development environments (IDE), 12 iomanip header file, 110 , 113 ios::app access flag, 658 ios::ate access flag, 658 ios::badbit status flag, 668 ios::binary access flag, 658 , 681 ios::eofbit status flag, 668 ios::failbit status flag, 668 ios::goodbit status ..."
T-U,1265,"swap member function, 443 list, 1057 string class, 590 switch statement, 202 – 211 break, 204 , 205 case, 203 – 204 default, 203 – 204 fallthrough capability, 205 – 207 with menus, 207 – 209 syntax, 14 syntax errors, 12 system software operating system, 7 software development tools, 7 utility program, 7 T tags, of structures, 602 , 604 tellg member function, file stream objects, 694 – 696 tellp member function, file stream objects, 694 – 696 template function, 990 template prefix, 990 , 995 , 997 templates binary trees, 1175–1181 class, 996 – 1005 defining, 995 , 996 dynamic queue, 1109–1112 dynamic stack, 1085 – 1090 function, 990 – 995 linked list, 1043 – 1055 prefixes, 990 , 995 specialized, 1004 – 1005 static queue, 1096 – 1100 static queues, 1101–1104 static stack, 1074 – 1079 type parameter, 990 ternary operators, 62 , 199 text editor, 11 text files described, 266 numeric data from, 276 – 277 this pointer, 835 – 837 throwing an exception, 523 , 972 throw key word, 972 , 987 th..."
